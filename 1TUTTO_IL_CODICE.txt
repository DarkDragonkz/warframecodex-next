DATA DUMP: 2025-12-24T02:29:24.818Z



==================================================
FILE: src\app\companions\page.js
==================================================

import { fetchGameData } from '@/utils/serverData';
import CodexListPage from '@/components/CodexListPage';

export default async function Page() {
    const [data, lookup] = await Promise.all([
        fetchGameData('Sentinels.json'),
        fetchGameData('RelicLookup.json')
    ]);

    return (
        <CodexListPage 
            initialData={data} 
            lookupData={lookup}
            pageTitle="COMPANIONS" 
            categoryMode="companions"
        />
    );
}

==================================================
FILE: src\app\error.js
==================================================

// src/app/error.js
"use client";

export default function Error({ error, reset }) {
  return (
    <div style={{padding: '50px', color: 'white', textAlign: 'center'}}>
      <h2 style={{color: '#ff6b6b'}}>SYSTEM FAILURE</h2>
      <p>Ordis has encountered an error:</p>
      <pre style={{background: '#222', padding: '20px', borderRadius: '5px', display:'inline-block', textAlign:'left'}}>
        {error.message}
      </pre>
      <br />
      <button 
        onClick={() => reset()} 
        style={{marginTop: '20px', padding: '10px 20px', background: '#d4af37', border: 'none', cursor: 'pointer', fontWeight:'bold'}}
      >
        REBOOT SYSTEM
      </button>
    </div>
  );
}

==================================================
FILE: src\app\globals.css
==================================================

@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --bg-deep: #050505;
  --bg-card: #121214;
  --bg-header: rgba(10, 10, 12, 0.90);
  --border-color: #27272a;
  --text-main: #ededed;
  --text-muted: #888888;
  --gold: #d4af37;
  --gold-dim: #8a7224;
  --gold-glow: rgba(212, 175, 55, 0.4);
  --blue-energy: #3b82f6;
  --blue-glow: rgba(59, 130, 246, 0.4);
  --green-tech: #5fffa5;
  --red-vault: #ff5555;
  --font-roboto: "Roboto Condensed", sans-serif;
}

* { box-sizing: border-box; padding: 0; margin: 0; }

html, body {
  height: 100%; width: 100%; background-color: var(--bg-deep); 
  color: var(--text-main); font-family: var(--font-roboto); overflow: hidden;
}

/* Scrollbars Universali */
div::-webkit-scrollbar { width: 6px; }
div::-webkit-scrollbar-track { background: #050505; }
div::-webkit-scrollbar-thumb { background: #333; border-radius: 3px; }
div::-webkit-scrollbar-thumb:hover { background: #555; }

==================================================
FILE: src\app\homepage.css
==================================================

/* src/app/homepage.css */

/* LAYOUT BASE */
.landing-page {
  /* 100dvh gestisce meglio le barre di indirizzo mobili (Safari/Chrome) */
  height: 100vh;
  height: 100dvh; 
  width: 100vw;
  background: #050505;
  position: relative;
  
  /* SBLOCCO SCROLL */
  overflow-y: auto; 
  overflow-x: hidden;
  -webkit-overflow-scrolling: touch; /* Scroll fluido iOS */
  
  /* Reset del flex sul contenitore padre per evitare blocchi */
  display: block; 
}

/* SFONDO TECNICO (Fisso, non scrolla col contenuto) */
.landing-page::before {
  content: ""; position: fixed; inset: 0;
  background-image: 
    linear-gradient(rgba(255, 255, 255, 0.03) 1px, transparent 1px),
    linear-gradient(90deg, rgba(255, 255, 255, 0.03) 1px, transparent 1px);
  background-size: 40px 40px;
  mask-image: radial-gradient(circle at center, black 0%, transparent 80%);
  pointer-events: none; z-index: 0;
}

/* VIGNETTATURA AI BORDI */
.landing-page::after {
  content: ""; position: fixed; inset: 0;
  background: radial-gradient(circle at center, transparent 0%, #000 90%);
  z-index: 1; pointer-events: none;
}

/* CONTENITORE CONTENUTO */
.landing-content {
  position: relative; z-index: 10;
  width: 100%;
  
  /* FIX CRUCIALE: Permette al contenuto di crescere oltre lo schermo */
  min-height: 100%; 
  
  /* FIX CRUCIALE: flex-start evita che il titolo venga tagliato fuori in alto */
  display: flex; 
  flex-direction: column; 
  align-items: center; 
  justify-content: flex-start; 

  /* Spazio abbondante sopra e sotto per lo scroll */
  padding: 80px 20px 60px 20px;
}

/* TITOLO E HEADER */
.landing-header {
  margin-bottom: 40px; 
  text-align: center;
  flex-shrink: 0;
  width: 100%;
  /* Rimuoviamo animazioni complesse che potrebbero nascondere il titolo su mobile */
  opacity: 1; 
  transform: none;
}

.landing-title {
  /* Font size responsivo e sicuro */
  font-size: 42px; 
  font-weight: 900; 
  color: #fff; /* Colore base di fallback */
  text-transform: uppercase; 
  letter-spacing: 6px; 
  line-height: 1.1;
  margin: 0;
  
  /* Gradiente testo */
  background: linear-gradient(to bottom, #ffffff 0%, #aaaaaa 100%);
  -webkit-background-clip: text; 
  background-clip: text;
  -webkit-text-fill-color: transparent;
  
  filter: drop-shadow(0 0 15px rgba(255,255,255,0.15));
}

@media (min-width: 768px) {
  .landing-title {
    font-size: 70px;
    letter-spacing: 10px;
  }
}

.landing-subtitle {
  font-size: 11px; color: var(--gold); 
  letter-spacing: 4px; text-transform: uppercase; 
  margin-top: 15px; font-weight: 700;
  text-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
  display: flex; align-items: center; justify-content: center; gap: 15px;
  text-align: center; line-height: 1.5;
}
.landing-subtitle::before, .landing-subtitle::after {
  content: ""; height: 1px; width: 30px; background: var(--gold); opacity: 0.5;
  display: inline-block;
}

/* GRIGLIA CARDS */
.cards-scroll-container { 
  width: 100%;
  display: flex; 
  justify-content: center;
  align-items: flex-start; /* Allineamento sicuro */
  margin-bottom: 20px;
}

.cards-row { 
  display: flex; 
  flex-wrap: wrap;
  justify-content: center; 
  gap: 15px; /* Gap ridotto per mobile */
  max-width: 1200px; 
  width: 100%;
}

@media (min-width: 768px) {
  .cards-row { gap: 20px; }
}

/* CARD MENU */
.menu-card {
  flex: 0 0 auto; 
  width: 155px; height: 230px; /* Dimensioni ottimizzate per 2 colonne su mobile */
  background: rgba(20, 20, 23, 0.6); /* Sfondo leggermente più scuro per contrasto */
  border: 1px solid rgba(255, 255, 255, 0.1);
  border-radius: 4px;
  position: relative; overflow: hidden; 
  display: flex; flex-direction: column; justify-content: flex-end;
  transition: transform 0.2s, box-shadow 0.2s;
  backdrop-filter: blur(4px); 
  text-decoration: none;
  margin-bottom: 5px; /* Sicurezza spaziatura */
}

@media (min-width: 768px) {
    .menu-card { width: 200px; height: 280px; }
}

/* INTERAZIONE CARD */
.menu-card:active { transform: scale(0.96); } /* Feedback tocco su mobile */
.menu-card:hover { 
  transform: translateY(-5px) scale(1.02); 
  border-color: var(--card-color); 
  box-shadow: 0 5px 20px -5px var(--card-glow); 
  z-index: 5;
}

/* VISUAL AREA */
.card-visual-area { 
  position: absolute; inset: 0; z-index: 0; 
  transition: 0.6s ease;
  filter: grayscale(100%) brightness(0.5) contrast(1.1);
}
.card-img-element { 
  width: 100%; height: 100%; object-fit: cover; 
}

.menu-card:hover .card-visual-area { 
  filter: grayscale(0%) brightness(1.1) contrast(1); 
  transform: scale(1.05);
}

/* CONTENUTO CARD TEXT */
.card-content { 
  position: relative; z-index: 2; 
  padding: 12px;
  background: linear-gradient(to top, rgba(0,0,0,0.95) 10%, rgba(0,0,0,0.6) 70%, transparent 100%); 
  width: 100%; 
  border-top: 1px solid rgba(255,255,255,0.05);
  transition: 0.3s;
}
.menu-card:hover .card-content {
  border-top-color: var(--card-color);
}

.card-title { 
  font-size: 15px; font-weight: 800; 
  text-transform: uppercase; color: #fff; 
  letter-spacing: 0.5px; margin-bottom: 3px; line-height: 1;
  text-shadow: 0 2px 4px rgba(0,0,0,0.8);
}
.menu-card:hover .card-title { color: var(--card-color); }

.card-sub { 
  font-size: 8px; color: #ccc; 
  text-transform: uppercase; letter-spacing: 1px; font-weight: 700;
}
.menu-card:hover .card-sub { color: #fff; }

/* FOOTER */
.landing-footer {
  margin-top: 30px;
  color: #555; font-size: 9px; 
  text-transform: uppercase; letter-spacing: 2px; 
  font-family: monospace;
  text-align: center;
}

==================================================
FILE: src\app\hud-layout.css
==================================================

/* LAYOUT CODEX */
.codex-layout { 
  display: flex; flex-direction: column; height: 100vh; width: 100vw; 
  overflow: hidden; background: radial-gradient(circle at top center, #15151a 0%, #000000 100%); 
}

/* HEADER HUD */
.header-group {
  flex-shrink: 0; background: var(--bg-header); backdrop-filter: blur(12px);
  z-index: 50; border-bottom: 1px solid rgba(255,255,255,0.05);
  box-shadow: 0 10px 30px rgba(0,0,0,0.5); display: flex; flex-direction: column;
}
.nav-top-row { display: flex; align-items: center; justify-content: space-between; padding: 0 40px; height: 70px; }

/* AGGIUNTO: Wrapper per Bottone Home e Titolo */
.nav-brand {
  display: flex; align-items: center; gap: 25px; /* Spazio prima della linea gialla */
}

.nav-home-btn { font-size: 11px; font-weight: bold; letter-spacing: 2px; color: var(--text-muted); text-decoration: none; text-transform: uppercase; padding: 8px 12px; border: 1px solid #333; border-radius: 4px; transition: all 0.3s; }
.nav-home-btn:hover { border-color: var(--gold); color: var(--gold); box-shadow: 0 0 10px var(--gold-glow); }

.page-title { font-size: 28px; font-weight: 900; color: #fff; text-transform: uppercase; letter-spacing: 2px; text-shadow: 0 0 20px rgba(255,255,255,0.1); border-left: 3px solid var(--gold); padding-left: 20px; line-height: 1; }

.stats-right { display: flex; align-items: center; gap: 30px; }
.stat-label { font-size: 9px; color: #666; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 2px; }
.stat-value { font-size: 18px; color: #fff; font-weight: 300; font-family: monospace; }
.stat-value span { color: var(--gold); font-weight: bold; }

/* CONTROLLI E FILTRI */
.controls-row { 
  display: flex; align-items: center; justify-content: space-between; 
  padding: 15px 40px; background: rgba(0,0,0,0.3); border-top: 1px solid rgba(255,255,255,0.03); 
}

.category-tabs {
  display: flex; background: #08080a; border: 1px solid #333; 
  border-radius: 4px; padding: 3px; gap: 2px;
}
.tab-btn {
  background: transparent; border: none; color: #666;
  padding: 6px 16px; font-size: 11px; font-weight: 800; letter-spacing: 1px;
  cursor: pointer; transition: all 0.3s; text-transform: uppercase; border-radius: 2px;
}
.tab-btn:hover { color: #fff; background: rgba(255,255,255,0.05); }
.tab-btn.active { 
  background: var(--gold); color: #000; 
  box-shadow: 0 0 15px var(--gold-glow); 
}

.filters-right { display: flex; align-items: center; gap: 20px; }

.search-input { 
  background: #08080a; border: 1px solid #333; color: #fff; 
  padding: 8px 15px; width: 220px; border-radius: 4px; font-size: 12px; 
  text-transform: uppercase; letter-spacing: 1px; transition: 0.3s; 
}
.search-input:focus { outline: none; border-color: var(--gold); box-shadow: 0 0 15px var(--gold-glow); background: #000; }

.toggle-filter { 
  display: flex; align-items: center; gap: 8px; cursor: pointer; 
  color: #888; font-size: 10px; font-weight: bold; text-transform: uppercase; letter-spacing: 1px; transition: 0.3s; 
}
.toggle-filter:hover { color: #fff; }

.checkbox-custom { 
  width: 16px; height: 16px; border: 1px solid #444; background: #08080a; 
  display: flex; align-items: center; justify-content: center; 
  color: var(--gold); border-radius: 3px; transition: 0.2s; 
}
.toggle-filter input:checked + .checkbox-custom { 
  border-color: var(--gold); box-shadow: 0 0 8px var(--gold-glow); background: rgba(212, 175, 55, 0.1); 
}

/* GRIGLIA E CARD */
.gallery-scroll-area { flex-grow: 1; overflow-y: auto; padding: 40px; scrollbar-width: thin; }
.card-gallery { display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 25px; padding-bottom: 100px; }

.card-wrapper {
  background: var(--bg-card); border: 1px solid var(--border-color); border-radius: 6px;
  overflow: hidden; display: flex; flex-direction: column; position: relative;
  transition: all 0.3s; box-shadow: 0 4px 6px rgba(0,0,0,0.3); height: 400px !important;
}
.card-wrapper:hover { transform: translateY(-5px); border-color: #555; }
.card-wrapper[data-rarity="Prime"] { border-top: 2px solid var(--gold); }

.card-image-container { 
  height: 180px; width: 100%; display: flex; align-items: center; justify-content: center; 
  padding: 15px; border-bottom: 1px solid #1a1a1e; 
  background: radial-gradient(circle, #1f1f25 0%, #121214 100%);
  position: relative;
}
.card-image-img { max-width: 100%; max-height: 100%; object-fit: contain; transition: 0.3s; }

.owned-check { 
  position: absolute; top: 10px; left: 10px; width: 24px; height: 24px; 
  background: rgba(0,0,0,0.6); border: 1px solid rgba(255,255,255,0.2); 
  display: flex; align-items: center; justify-content: center; 
  color: #fff; z-index: 10; border-radius: 4px; cursor: pointer; transition: 0.2s; 
}
.owned-check:hover { border-color: var(--gold); color: var(--gold); }
.card-wrapper.owned .owned-check { background: var(--blue-energy); border-color: var(--blue-energy); box-shadow: 0 0 10px var(--blue-glow); }
.card-wrapper.owned .card-image-img { filter: grayscale(100%) brightness(0.6); }

.vaulted-tag-card {
  position: absolute; top: 10px; right: 10px;
  background: rgba(200, 0, 0, 0.2); backdrop-filter: blur(4px);
  border: 1px solid #ff5555; color: #ff5555;
  font-size: 9px; font-weight: 900; letter-spacing: 1px;
  padding: 4px 8px; border-radius: 3px;
  z-index: 10; text-transform: uppercase;
  box-shadow: 0 0 10px rgba(255, 0, 0, 0.2);
}

.info-area { 
  padding: 15px; flex-grow: 1; display: flex; flex-direction: column; 
  align-items: center; text-align: center; background: #151518;
  justify-content: space-between;
}

.mod-name { font-size: 15px; font-weight: 800; text-transform: uppercase; color: #fff; margin-bottom: 4px; letter-spacing: 0.5px; }
.type-pill { font-size: 9px; color: #555; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px; font-weight: bold; }
.card-desc { 
  font-size: 11px; color: #888; line-height: 1.4; 
  margin-bottom: auto; width: 100%; overflow: hidden; 
  display: -webkit-box; -webkit-line-clamp: 4; -webkit-box-orient: vertical; 
}

.progress-line-container { width: 100%; height: 2px; background: #222; margin-top: auto; }
.progress-line-fill { height: 100%; background: var(--gold); box-shadow: 0 0 10px var(--gold); transition: width 0.6s; }

.wiki-btn-block { 
  display: block; width: 100%; margin-top: 15px; padding: 8px; 
  background: transparent; text-align: center; 
  font-size: 10px; font-weight: 800; letter-spacing: 2px;
  color: #666; border: 1px solid #333; border-radius: 2px; 
  text-transform: uppercase; text-decoration: none;
  transition: all 0.2s; 
}
.wiki-btn-block:hover { 
  color: #fff; border-color: #666; background: #1a1a1e; 
}
.card-wrapper {
  content-visibility: auto;
  contain-intrinsic-size: 400px; /* Altezza stimata della card */
}
/* ... contenuto esistente ... */

/* =========================================
   MEDIA QUERIES PER MOBILE (HUD)
   ========================================= */

@media (max-width: 768px) {
  /* Rimuove overflow: hidden per permettere lo scroll della pagina intera se serve,
     anche se qui manteniamo la logica dello scroll interno */
  .codex-layout {
    height: 100dvh; /* Usa dynamic viewport height per mobile browser moderni */
  }

  /* Header: Riduciamo altezza e padding */
  .nav-top-row {
    padding: 0 15px;
    height: 60px;
  }

  .nav-brand {
    gap: 15px;
  }

  .page-title {
    font-size: 20px; /* Titolo più piccolo */
    padding-left: 10px;
  }
  
  /* Nascondiamo le statistiche complete su mobile se non c'è spazio, 
     oppure le riduciamo */
  .stats-right {
    gap: 10px;
  }
  .stat-box {
    display: flex; flex-direction: column; align-items: flex-end;
  }
  .stat-label { font-size: 7px; }
  .stat-value { font-size: 14px; }

  /* Controlli (Filtri e Ricerca): Impilamento Verticale */
  .controls-row {
    flex-direction: column;
    align-items: stretch; /* Allarga tutto a larghezza piena */
    gap: 15px;
    padding: 15px;
    height: auto; /* Lascia che l'altezza si adatti */
  }

  /* I tab delle categorie devono essere scrollabili orizzontalmente */
  .filters-left {
    max-width: 100% !important;
    overflow-x: auto;
    padding-bottom: 5px; /* Spazio per scrollbar */
  }
  
  .filters-right {
    flex-direction: column; /* Impila input ricerca e checkbox */
    gap: 10px;
    width: 100%;
  }

  .search-wrapper, .search-input {
    width: 100%; /* Barra di ricerca a larghezza piena */
  }

  .legend-box {
    display: none; /* Nascondi la legenda su mobile per risparmiare spazio */
  }

  .toggle-filter {
    width: 100%;
    justify-content: flex-start; /* Allinea checkbox a sinistra */
    padding: 5px 0;
  }

  /* Griglia Cards */
  .gallery-scroll-area {
    padding: 15px; /* Meno padding laterale */
  }
  
  .card-gallery {
    /* Riduciamo la dimensione minima delle card per farne stare 2 su schermi piccoli */
    grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
    gap: 15px;
  }

  /* Adattamento Card */
  .card-wrapper {
    height: 320px !important; /* Card leggermente più basse */
  }
  .card-image-container {
    height: 140px;
  }
}

==================================================
FILE: src\app\layout.js
==================================================

import { Roboto_Condensed } from "next/font/google";
import './globals.css'; // Carica solo le basi per tutta l'app

const robotoCondensed = Roboto_Condensed({ 
  subsets: ["latin"], 
  weight: ["300", "400", "700"],
  variable: "--font-roboto",
});

export const metadata = {
  title: "Ordis Codex",
  description: "Warframe Tracker",
};

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body className={robotoCondensed.className}>
        {children}
      </body>
    </html>
  );
}

==================================================
FILE: src\app\melee\page.js
==================================================

import { fetchGameData } from '@/utils/serverData';
import CodexListPage from '@/components/CodexListPage';

export default async function Page() {
    const [data, lookup] = await Promise.all([
        fetchGameData('Melee.json'),
        fetchGameData('RelicLookup.json')
    ]);

    return (
        <CodexListPage 
            initialData={data} 
            lookupData={lookup}
            pageTitle="MELEE WEAPONS" 
            categoryMode="melee"
        />
    );
}

==================================================
FILE: src\app\modal.css
==================================================

/* =========================================
   STILE FINESTRA MODALE (WARFRAME DETAIL)
   ========================================= */

.modal-overlay {
  position: fixed; top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0, 0, 0, 0.9);
  backdrop-filter: blur(8px);
  z-index: 1000;
  display: flex; align-items: center; justify-content: center;
  padding: 20px;
}

.modal-content.three-columns {
  width: 95vw;
  height: 90vh;
  max-width: 1600px;
  display: flex;
  flex-direction: row; /* Layout Orizzontale a 3 Colonne */
  background: #141418;
  border: 1px solid #444;
  border-top: 3px solid var(--gold);
  overflow: hidden;
  position: relative;
  box-shadow: 0 0 50px rgba(0,0,0,1);
}

.close-btn {
  position: absolute; top: 5px; right: 10px; background: none;
  border: none; color: #fff; font-size: 30px; cursor: pointer; z-index: 20;
}
.close-btn:hover { color: var(--gold); }

/* --- COLONNE COMUNI --- */
.column-info, .column-relics, .column-strategy {
  display: flex; flex-direction: column; height: 100%;
  border-right: 2px solid #2a2a2e;
  overflow: hidden;
}

/* --- COLONNA 1: INFO (25%) --- */
.column-info { flex: 0 0 25%; min-width: 300px; background: #101012; padding: 20px; }

.det-title { font-size: 24px; color: #fff; margin: 0; text-transform: uppercase; }
.det-subtitle { color: var(--gold); font-size: 12px; margin-bottom: 20px; }
.det-img-box { flex-grow: 1; display: flex; align-items: center; justify-content: center; }
.det-img-box img { max-width: 100%; max-height: 250px; filter: drop-shadow(0 0 10px #000); }
.det-desc { font-size: 12px; color: #888; overflow-y: auto; max-height: 150px; margin-bottom: 20px; line-height: 1.5; }

/* Mini lista posseduti */
.mini-owned-list { background: #1a1a1e; padding: 10px; border-radius: 4px; border: 1px solid #333; }
.mini-own-item { font-size: 11px; color: #888; margin-bottom: 4px; border-bottom: 1px solid #222; padding-bottom: 2px; }
.mini-own-item.ok { color: #2ecc71; font-weight: bold; }
.mini-own-item b { float: right; }

/* --- COLONNA 2: RELIQUIE (35%) --- */
.column-relics { flex: 0 0 35%; background: #0e0e10; }

.col-header {
  padding: 15px; background: #000; border-bottom: 1px solid #333;
  font-size: 14px; font-weight: bold; color: #fff; letter-spacing: 1px;
  text-transform: uppercase; text-align: center; border-left: 4px solid var(--gold);
}

.col-scrollable { padding: 15px; overflow-y: auto; flex-grow: 1; }
.tier-grid { display: flex; flex-wrap: wrap; gap: 8px; align-content: flex-start; }

.relic-sub-group { margin-bottom: 25px; border-bottom: 1px dashed #333; padding-bottom: 15px; }
.relic-sub-group:last-child { border-bottom: none; }

.relic-sub-group-title {
  font-size: 11px; font-weight: 800; color: #fff; background: #222;
  padding: 5px 10px; border-left: 3px solid var(--blue-energy); margin-bottom: 10px;
  text-transform: uppercase; letter-spacing: 1px;
}

/* Card Reliquia */
.relic-card-item {
  width: 90px; height: 100px;
  background: #1a1a1e; border: 1px solid #333; border-radius: 4px;
  display: flex; flex-direction: column; align-items: center; justify-content: center;
  position: relative; cursor: pointer; transition: transform 0.1s;
  flex-shrink: 0;
}
.relic-card-item:hover { transform: translateY(-2px); background: #222; }
.relic-card-item.active { border-color: var(--gold); box-shadow: 0 0 8px rgba(212,175,55,0.3); z-index: 5; }
.relic-card-item.vaulted { border-top: 3px solid #e55; }
.relic-card-item.available { border-top: 3px solid #2ecc71; }

.r-icon-area img { width: 40px; height: 40px; object-fit: contain; margin-bottom: 5px; }
.r-name { font-size: 10px; font-weight: bold; color: #fff; text-align: center; }
.r-status { font-size: 7px; opacity: 0.8; margin-bottom: 4px; }
.r-check {
  position: absolute; top: 2px; right: 2px; background: var(--gold); color: #000;
  width: 14px; height: 14px; font-size: 9px; display: flex; align-items: center;
  justify-content: center; border-radius: 50%;
}

/* Badge e Rarità */
.rarity-bar { position: absolute; bottom: 0; left: 0; width: 100%; height: 4px; }
.bar-bronze { background: #cd7f32; box-shadow: 0 0 5px #cd7f32; }
.bar-silver { background: #c0c0c0; box-shadow: 0 0 5px #c0c0c0; }
.bar-gold   { background: #d4af37; box-shadow: 0 0 8px #d4af37; }

.relic-chance-badge {
  position: absolute; top: 4px; right: 4px; left: auto; color: #000;
  font-size: 8px; font-weight: 800; padding: 1px 4px; border-radius: 2px;
  z-index: 10; box-shadow: 0 2px 4px rgba(0,0,0,0.8);
}

/* --- COLONNA 3: STRATEGIA (40% - Restante) --- */
.column-strategy { flex: 1; background: #111; border-right: none; }

.strategy-list { display: flex; flex-direction: column; gap: 10px; }

.mission-card { background: #1a1a1e; border: 1px solid #333; border-radius: 4px; overflow: hidden; }

.mc-header {
  background: #222; padding: 8px 10px; border-bottom: 1px solid #333;
  display: flex; justify-content: space-between; align-items: center;
}

.mc-loc { color: #fff; font-weight: bold; font-size: 13px; }
.mc-rot-badge { color: var(--gold); font-weight: 800; margin-left: 5px; text-transform: uppercase; }
.mc-type { color: #aaa; font-size: 11px; text-transform: uppercase; font-weight: bold; }

/* Lista Testo Strategia */
.mc-relics-list { padding: 8px 12px; }

.mc-text-row {
  font-size: 12px; margin-bottom: 4px; border-bottom: 1px solid #252525;
  padding-bottom: 2px; color: #ccc; display: flex; align-items: center;
}
.mc-text-row:last-child { border-bottom: none; }

.mt-comp { color: #888; font-weight: bold; margin-right: 5px; min-width: 70px; }
.mt-relic { color: #fff; font-weight: bold; }
.mt-rot { color: var(--gold); font-weight: bold; margin-left: 5px; }
.mt-chance { color: var(--blue-energy); margin-left: auto; font-weight: bold; }

/* Stati vuoti */
.empty-state-placeholder, .col-loading, .col-empty, .strategy-placeholder, .strategy-empty {
  padding: 30px; text-align: center; color: #666; font-size: 12px;
  display: flex; align-items: center; justify-content: center; height: 100%; font-style: italic;
}
/* src/app/modal.css */

/* MODALE GENERALE */
.modal-overlay {
  position: fixed; inset: 0; background: rgba(0, 0, 0, 0.9);
  backdrop-filter: blur(10px); z-index: 1000;
  display: flex; align-items: center; justify-content: center;
}

.modal-content.three-columns {
  width: 95vw; height: 90vh; max-width: 1600px;
  display: flex; background: #121214;
  border: 1px solid #333; border-top: 3px solid var(--gold);
  position: relative; box-shadow: 0 0 50px #000;
}

.close-btn {
  position: absolute; top: 15px; right: 20px; font-size: 28px;
  color: #fff; background: none; border: none; cursor: pointer; z-index: 50;
}
.close-btn:hover { color: var(--gold); }

/* LAYOUT COLONNE */
.column-info { flex: 0 0 25%; background: #0a0a0c; padding: 30px; border-right: 1px solid #333; display: flex; flex-direction: column; }
.column-components { flex: 0 0 40%; background: #121214; padding: 0; border-right: 1px solid #333; display: flex; flex-direction: column; overflow: hidden; }
.column-strategy { flex: 1; background: #0e0e10; padding: 0; display: flex; flex-direction: column; overflow: hidden; }

/* COL 1: INFO */
.det-title { font-size: 36px; font-weight: 900; color: #fff; margin: 0; text-transform: uppercase; line-height: 1; }
.det-subtitle { color: var(--gold); font-size: 14px; font-weight: bold; margin-bottom: 30px; text-transform: uppercase; letter-spacing: 1px; }
.det-img-box { flex: 1; display: flex; align-items: center; justify-content: center; margin-bottom: 20px; }
.det-img-box img { width: 100%; max-height: 400px; object-fit: contain; filter: drop-shadow(0 0 30px rgba(0,0,0,0.5)); }
.det-desc { font-size: 13px; color: #888; line-height: 1.6; max-height: 200px; overflow-y: auto; padding-right: 10px; }

/* COL 2: COMPONENTI */
.col-header { padding: 20px; font-size: 14px; font-weight: 800; color: #fff; background: #1a1a1e; border-bottom: 1px solid #333; letter-spacing: 1px; display: flex; justify-content: space-between; align-items: center; }
.col-scrollable { flex: 1; overflow-y: auto; padding: 20px; }

.component-block { margin-bottom: 25px; background: #18181b; border: 1px solid #27272a; border-radius: 8px; padding: 15px; }
.comp-name { font-size: 14px; font-weight: bold; color: #fff; margin-bottom: 10px; text-transform: uppercase; border-left: 3px solid var(--blue-energy); padding-left: 10px; display: flex; justify-content: space-between; }
.comp-owned { font-size: 10px; color: #666; }
.comp-owned.yes { color: #2ecc71; }

.relic-chips-container { display: flex; flex-wrap: wrap; gap: 8px; }
.relic-chip {
  background: #222; border: 1px solid #444; padding: 6px 12px;
  border-radius: 4px; cursor: pointer; display: flex; align-items: center; gap: 8px;
  transition: all 0.2s; position: relative;
}
.relic-chip:hover { border-color: #fff; background: #333; }
.relic-chip.selected { background: var(--gold); border-color: var(--gold); color: #000; box-shadow: 0 0 10px rgba(212,175,55,0.4); }
.relic-chip.vaulted { opacity: 0.6; border-style: dashed; }

.rc-name { font-size: 12px; font-weight: 800; }
.rc-rarity { width: 6px; height: 6px; border-radius: 50%; }
.rarity-Common { background: #cd7f32; }
.rarity-Uncommon { background: #c0c0c0; }
.rarity-Rare { background: #d4af37; }

/* COL 3: STRATEGIA */
.strategy-list { display: flex; flex-direction: column; gap: 10px; }
.strategy-placeholder { padding: 40px; text-align: center; color: #555; font-style: italic; font-size: 13px; }

.mission-row {
  display: flex; justify-content: space-between; align-items: center;
  background: #1a1a1e; border: 1px solid #333; padding: 10px 15px; border-radius: 4px;
}
.ms-loc { font-weight: bold; color: #fff; font-size: 13px; }
.ms-relic { color: var(--gold); font-size: 11px; font-weight: bold; margin-left: 10px; }
.ms-chance { color: var(--blue-energy); font-weight: bold; font-size: 12px; }

.vault-warning {
  background: rgba(231, 76, 60, 0.1); border: 1px solid #e74c3c; color: #e74c3c;
  padding: 15px; text-align: center; font-weight: bold; border-radius: 4px; margin-bottom: 10px;
}

/* src/app/modal.css */

/* SFONDO E CONTENITORE PRINCIPALE */
.modal-overlay {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  background: rgba(0, 0, 0, 0.9); backdrop-filter: blur(5px);
  z-index: 1000; display: flex; align-items: center; justify-content: center;
}

.modal-content.three-columns {
  width: 95vw; height: 90vh; max-width: 1600px;
  background: #121214; border: 1px solid #333; border-top: 3px solid var(--gold);
  display: flex; flex-direction: row; /* FONDAMENTALE: ORIZZONTALE */
  overflow: hidden; position: relative; box-shadow: 0 0 50px #000;
}

.close-btn {
  position: absolute; top: 10px; right: 20px; font-size: 30px;
  color: #fff; background: none; border: none; cursor: pointer; z-index: 100;
}
.close-btn:hover { color: var(--gold); }

/* DEFINIZIONE COLONNE */
.column-info { 
  flex: 0 0 25%; /* Larghezza fissa 25% */
  background: #0a0a0c; border-right: 1px solid #333; 
  display: flex; flex-direction: column; padding: 30px;
}

.column-components { 
  flex: 0 0 40%; /* Larghezza fissa 40% */
  background: #121214; border-right: 1px solid #333; 
  display: flex; flex-direction: column; 
}

.column-strategy { 
  flex: 1; /* Il resto dello spazio */
  background: #0e0e10; 
  display: flex; flex-direction: column; 
}

/* STILI INTERNI */
.det-title { font-size: 32px; font-weight: 900; color: #fff; margin: 0; text-transform: uppercase; }
.det-subtitle { color: var(--gold); font-size: 14px; font-weight: bold; margin-bottom: 20px; }
.det-img-box { flex: 1; display: flex; align-items: center; justify-content: center; margin-bottom: 20px; }
.det-img-box img { width: 100%; max-height: 400px; object-fit: contain; filter: drop-shadow(0 0 20px rgba(0,0,0,0.5)); }
.det-desc { font-size: 13px; color: #888; line-height: 1.5; overflow-y: auto; max-height: 200px; }

/* HEADER E SCROLL AREA PER COLONNE 2 e 3 */
.col-header { 
  padding: 15px; background: #1a1a1e; border-bottom: 1px solid #333; 
  font-size: 14px; font-weight: 800; color: #fff; letter-spacing: 1px; text-transform: uppercase;
}
.col-scrollable { flex: 1; overflow-y: auto; padding: 20px; }

/* COMPONENTI */
.component-block { margin-bottom: 20px; background: #18181b; border: 1px solid #27272a; border-radius: 6px; padding: 15px; }
.comp-name { font-size: 14px; font-weight: bold; color: #fff; margin-bottom: 10px; display: flex; justify-content: space-between; border-left: 3px solid var(--blue-energy); padding-left: 10px; }
.comp-owned { font-size: 10px; color: #666; font-weight: normal; }
.comp-owned.yes { color: #2ecc71; font-weight: bold; }

/* CHIPS RELIQUIE */
.relic-chips-container { display: flex; flex-wrap: wrap; gap: 8px; }
.relic-chip {
  background: #222; border: 1px solid #444; padding: 5px 10px; border-radius: 4px;
  cursor: pointer; display: flex; align-items: center; gap: 6px; transition: 0.2s;
}
.relic-chip:hover { border-color: #fff; background: #333; }
.relic-chip.selected { background: var(--gold); border-color: var(--gold); color: #000; }
.relic-chip.vaulted { opacity: 0.5; border-style: dashed; }

.rc-name { font-size: 11px; font-weight: 700; }
/* Pallini rarità */
.rc-rarity { width: 6px; height: 6px; border-radius: 50%; }
.rarity-Common { background: #cd7f32; box-shadow: 0 0 5px #cd7f32; }
.rarity-Uncommon { background: #c0c0c0; box-shadow: 0 0 5px #c0c0c0; }
.rarity-Rare { background: #d4af37; box-shadow: 0 0 5px #d4af37; }

/* MISSIONI */
.mission-row { 
  display: flex; justify-content: space-between; align-items: center; 
  padding: 8px 12px; background: #1a1a1e; border: 1px solid #333; 
  border-radius: 4px; margin-bottom: 8px; 
}
.ms-loc { font-weight: bold; color: #fff; font-size: 12px; }
.ms-relic { font-size: 10px; color: var(--gold); font-weight: bold; margin-bottom: 2px; }
.ms-chance { font-size: 11px; color: var(--blue-energy); font-weight: bold; }
.vault-warning { color: #e74c3c; border: 1px solid #e74c3c; padding: 10px; text-align: center; border-radius: 4px; font-weight: bold; font-size: 12px; margin-bottom: 15px; background: rgba(231,76,60,0.1); }
.strategy-placeholder { text-align: center; padding: 40px; color: #555; font-style: italic; font-size: 13px; }

==================================================
FILE: src\app\mods\mods.css
==================================================

/* src/app/mods/mods.css */

/* --- LEGENDA & COLORS --- */
.legend-box {
    display: flex; gap: 15px; margin-right: 20px;
    background: rgba(0,0,0,0.3); padding: 5px 10px; border-radius: 4px; border: 1px solid #333;
}
.legend-item { display: flex; align-items: center; gap: 6px; font-size: 10px; font-weight: bold; color: #888; }
.dot-leg { width: 8px; height: 8px; border-radius: 50%; display: inline-block; }

.dot-leg.mission { background: #48dbfb; box-shadow: 0 0 5px #48dbfb; }
.dot-leg.enemy { background: #ff6b6b; box-shadow: 0 0 5px #ff6b6b; }
.dot-leg.shop { background: #feca57; box-shadow: 0 0 5px #feca57; }

/* VARS LOCALI PER I COLORI */
.mods-container {
    --mission: #48dbfb;
    --enemy: #ff6b6b;
}

/* --- CARD DESIGN --- */
.mod-card-wrapper { 
    width: 220px; height: 340px; 
    perspective: 1000px; cursor: default; 
    position: relative; margin-bottom: 10px;
}

.mod-card-inner { 
    position: relative; width: 100%; height: 100%; 
    text-align: center; transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); 
    transform-style: preserve-3d; 
}
.mod-card-wrapper.flipped .mod-card-inner { transform: rotateY(180deg); }

.mod-card-front, .mod-card-back { 
    position: absolute; width: 100%; height: 100%; 
    backface-visibility: hidden; border-radius: 6px; overflow: hidden; 
    background-color: #151515; border: 1px solid #444; 
    display: flex; flex-direction: column; 
    box-shadow: 0 4px 10px rgba(0,0,0,0.5); 
}

/* RARITY BORDERS */
.mod-card-wrapper[data-rarity="Common"] .mod-card-front { border-color: #a89686; }
.mod-card-wrapper[data-rarity="Uncommon"] .mod-card-front { border-color: #c0c0c0; }
.mod-card-wrapper[data-rarity="Rare"] .mod-card-front { border-color: #d4af37; }
.mod-card-wrapper[data-rarity="Legendary"] .mod-card-front { border-color: #b0c9ec; }
.mod-card-wrapper[data-rarity="Arcane"] .mod-card-front { border-color: #00ffcc; }

/* CHECKBOX & DRAIN */
.mod-owned-check { 
    position: absolute; top: 0; left: 0; background: rgba(0,0,0,0.9); 
    color: #666; width: 35px; height: 30px; font-size: 16px; 
    z-index: 50; cursor: pointer; border-bottom-right-radius: 8px; 
    display: flex; align-items: center; justify-content: center; 
    border-bottom: 1px solid #444; border-right: 1px solid #444; 
    transition: 0.2s; 
}
.mod-owned-check:hover { background: #333; color: #fff; }
.mod-card-wrapper.owned .mod-owned-check { background: var(--blue-energy); color: #fff; border-color: var(--blue-energy); }
.mod-card-wrapper.owned .mod-card-img { filter: grayscale(100%) brightness(0.5); }

.mod-drain-box { 
    position: absolute; top: 0; right: 0; background: rgba(0,0,0,0.9); 
    color: #fff; padding: 4px 10px; font-weight: bold; font-size: 14px; 
    z-index: 20; border-bottom-left-radius: 8px; 
    display: flex; align-items: center; gap: 6px; 
    border-bottom: 1px solid #444; border-left: 1px solid #444; 
}

.mod-card-img-container { width: 100%; height: 50%; background-color: #000; position: relative; }
.mod-card-img { width: 100%; height: 100%; object-fit: cover; object-position: top; }

.mod-info-area { 
    flex-grow: 1; background: #151515; 
    display: flex; flex-direction: column; align-items: center; 
    padding: 10px; position: relative; z-index: 5; justify-content: flex-start; 
}
.mod-type-pill { 
    background: #000; border: 1px solid #444; border-radius: 12px; 
    padding: 2px 10px; font-size: 9px; font-weight: bold; 
    color: #bbb; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 6px; 
}
.mod-name { 
    font-size: 13px; font-weight: 800; text-transform: uppercase; 
    color: #fff; margin-bottom: 4px; text-align: center; 
    width: 100%; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; 
}
.mod-desc { 
    font-size: 10px; color: #ccc; text-align: center; line-height: 1.3; 
    display: -webkit-box; -webkit-line-clamp: 4; -webkit-box-orient: vertical; 
    overflow: hidden; width: 100%; flex-grow: 1; 
}

/* RANK CONTROLS */
.mod-rank-controls { 
    display: flex; width: 100%; align-items: center; justify-content: space-between; 
    padding-top: 8px; border-top: 1px solid #222; margin-top: auto; 
}
.mod-rank-btn { 
    background: #222; border: 1px solid #444; color: #fff; font-weight: bold; 
    cursor: pointer; width: 20px; height: 20px; border-radius: 3px; 
    display: flex; align-items: center; justify-content: center; font-size: 14px; 
}
.mod-rank-btn:hover { border-color: var(--gold); color: var(--gold); }
.mod-ranks-dots { display: flex; justify-content: center; gap: 2px; flex-grow: 1; padding: 0 5px; flex-wrap: wrap; }
.mod-dot { width: 5px; height: 5px; border-radius: 50%; background: #333; transition: 0.2s; }
.mod-dot.active { background: var(--gold); box-shadow: 0 0 5px var(--gold-glow); }

/* BACK SIDE */
.mod-card-back { 
    background: #121212; 
    transform: rotateY(180deg); padding: 0; text-align: left; position: relative; 
}
.mod-back-header { 
    padding: 10px; border-bottom: 1px solid #333; background: rgba(0,0,0,0.6); 
    display: flex; justify-content: space-between; align-items: center; 
}
.mod-back-title { color: #fff; font-size: 12px; font-weight: bold; text-transform: uppercase; }
.mod-trade-badge { font-size: 8px; color: #2ecc71; border: 1px solid #2ecc71; padding: 1px 4px; border-radius: 2px; }

.mod-source-content { 
    flex-grow: 1; overflow-y: auto; font-size: 10px; color: #ccc; 
    padding: 10px; padding-bottom: 40px; scrollbar-width: thin; 
}
.mod-drop-row { display: flex; flex-direction: column; border-bottom: 1px solid #222; padding: 6px 0; }
.mod-drop-header { display: flex; justify-content: space-between; margin-bottom: 3px; }
.mod-drop-loc { font-weight: bold; color: #ddd; max-width: 80%; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; display: flex; align-items: center; }
.mod-drop-pct { color: #aaa; font-family: monospace; }
.mod-drop-bar-bg { width: 100%; height: 2px; background: #222; border-radius: 2px; }
.mod-drop-bar-fill { height: 100%; transition: width 0.3s; }
.mod-no-drop { text-align: center; color: #555; font-style: italic; margin-top: 20px; }

.mod-wiki-btn { 
    position: absolute; bottom: 0; left: 0; width: 100%; 
    background: #1a1a1a; border-top: 1px solid #444; color: #eee; 
    padding: 10px 0; font-size: 11px; text-align: center; text-decoration: none; 
    font-weight: 700; text-transform: uppercase; display: block; cursor: pointer;
}
.mod-wiki-btn:hover { color: var(--gold); background: #222; }
.mod-card-wrapper {
    content-visibility: auto;
    contain-intrinsic-size: 340px; /* Altezza stimata della Mod card */
}

==================================================
FILE: src\app\mods\ModsClientPage.js
==================================================

"use client";
import React, { useState, useEffect, useMemo } from 'react';
import Link from 'next/link';
import { IMG_BASE_URL } from '@/utils/constants';
import '@/app/hud-layout.css'; 
import './mods.css';

const STORAGE_KEY = 'warframe_codex_mods_v1';

export default function ModsClientPage({ initialData = [] }) {
    const [rawApiData, setRawApiData] = useState([]);
    const [ownedCards, setOwnedCards] = useState(new Set());
    const [loading, setLoading] = useState(true);

    // Filtri
    const [currentCategory, setCurrentCategory] = useState('all');
    
    // Ricerca con Debounce
    const [searchTerm, setSearchTerm] = useState('');
    const [debouncedSearch, setDebouncedSearch] = useState('');

    const [currentSort, setCurrentSort] = useState('name');
    const [showMissingOnly, setShowMissingOnly] = useState(false);
    const [visibleCount, setVisibleCount] = useState(60);

    // Debounce Effect
    useEffect(() => {
        const timer = setTimeout(() => {
            setDebouncedSearch(searchTerm);
        }, 300);
        return () => clearTimeout(timer);
    }, [searchTerm]);

    // 1. Inizializzazione Dati (da Props)
    useEffect(() => {
        if(initialData && initialData.length > 0) {
            const processed = [];
            const ids = new Set();

            initialData.forEach(item => {
                if (!item.imageName || item.name.includes("Riven") || (item.uniqueName && item.uniqueName.includes("/PVP"))) return;
                if (item.uniqueName && item.uniqueName.toLowerCase().includes("setmod")) return;
                if (ids.has(item.name)) return; 
                
                ids.add(item.name);
                
                const dropLocs = item.drops ? item.drops.map(d => d.location).join(" ") : "";
                // Pre-calcolo stringa ricerca
                item.searchString = `${item.name} ${item.type} ${item.category || ""} ${dropLocs}`.toLowerCase();
                item.maxRank = (typeof item.fusionLimit === 'number') ? item.fusionLimit : 5;
                
                processed.push(item);
            });
            processed.sort((a, b) => a.name.localeCompare(b.name));
            setRawApiData(processed);
            setLoading(false);
        }

        // Carica salvataggi locali
        const saved = localStorage.getItem(STORAGE_KEY);
        if (saved) {
            try { setOwnedCards(new Set(JSON.parse(saved))); } catch (e) { console.error(e); }
        }
    }, [initialData]);

    // 2. Salvataggio automatico
    useEffect(() => {
        if (!loading && typeof window !== 'undefined') {
            localStorage.setItem(STORAGE_KEY, JSON.stringify([...ownedCards]));
        }
    }, [ownedCards, loading]);

    // 3. Logica Filtri
    const filteredData = useMemo(() => {
        let data = rawApiData.filter(item => {
            // Usa debouncedSearch
            if (debouncedSearch && !item.searchString.includes(debouncedSearch)) return false;
            if (showMissingOnly && ownedCards.has(item.uniqueName)) return false;
            
            const t = (item.type || "").toLowerCase();
            const slot = (item.slot || "").toLowerCase();
            const cat = (item.category || "").toLowerCase();
            const isAugment = item.isAugment || item.name.includes("Augment");
            const isAura = t.includes("aura") || slot === "aura";
            const isArcane = cat.includes("arcane") || t.includes("arcane");

            switch (currentCategory) {
                case 'all': return true;
                case 'warframe': return t.includes("warframe") && !isAura && !isAugment && !isArcane;
                case 'aura': return isAura;
                case 'augment': return isAugment;
                case 'arcane': return isArcane;
                case 'primary': return (t.includes("rifle") || t.includes("bow") || t.includes("shotgun") || t.includes("sniper")) && !isAugment;
                case 'secondary': return (t.includes("pistol") || t.includes("secondary")) && !isAugment;
                case 'melee': return (t.includes("melee")) && !isAugment;
                case 'exilus': return item.isExilus || slot === "exilus";
                case 'companion': return t.includes("companion") || t.includes("sentinel") || t.includes("beast");
                case 'archwing': return t.includes("archwing") || t.includes("arch-gun");
                default: return true;
            }
        });

        const rarityMap = { 'Common': 1, 'Uncommon': 2, 'Rare': 3, 'Legendary': 4 };
        data.sort((a, b) => {
            if (currentSort === 'name') return a.name.localeCompare(b.name);
            if (currentSort === 'drain') return (b.baseDrain || 0) - (a.baseDrain || 0);
            if (currentSort === 'rarity') {
                const rA = rarityMap[a.rarity] || 0;
                const rB = rarityMap[b.rarity] || 0;
                if (rA !== rB) return rB - rA;
                return a.name.localeCompare(b.name);
            }
            if (currentSort === 'chance') {
                const maxA = a.drops && a.drops.length ? Math.max(...a.drops.map(d=>d.chance)) : 0;
                const maxB = b.drops && b.drops.length ? Math.max(...b.drops.map(d=>d.chance)) : 0;
                return maxA - maxB;
            }
            return 0;
        });
        return data;
    }, [rawApiData, currentCategory, debouncedSearch, currentSort, showMissingOnly, ownedCards]);

    const toggleOwned = (id) => {
        const newSet = new Set(ownedCards);
        if (newSet.has(id)) newSet.delete(id); else newSet.add(id);
        setOwnedCards(newSet);
    };

    const pct = rawApiData.length > 0 ? Math.round((ownedCards.size / rawApiData.length) * 100) : 0;

    if (loading) return <div style={{color:'#fff', padding:'50px', textAlign:'center'}}>PROCESSING ORDIS DATA...</div>;

    return (
        <div className="codex-layout">
            <div className="header-group">
                <div className="nav-top-row">
                    <div className="nav-brand">
                        <Link href="/" className="nav-home-btn">⌂ HOME</Link>
                        <h1 className="page-title">MODS & ARCANES</h1>
                    </div>
                    <div className="stats-right">
                        <div className="stat-box">
                            <div className="stat-label">COLLECTED</div>
                            <div className="stat-value"><span>{ownedCards.size}</span> / {rawApiData.length}</div>
                        </div>
                        <div className="stat-box">
                            <div className="stat-label">COMPLETION</div>
                            <div className="stat-value">{pct}%</div>
                        </div>
                    </div>
                </div>

                <div className="controls-row">
                    <div className="filters-left" style={{overflowX:'auto', maxWidth:'60%'}}>
                        <div className="category-tabs" style={{flexWrap:'nowrap'}}>
                            {['all','warframe','aura','augment','arcane','primary','secondary','melee','exilus','companion','archwing'].map(cat => (
                                <button 
                                    key={cat}
                                    className={`tab-btn ${currentCategory === cat ? 'active' : ''}`}
                                    onClick={() => { setCurrentCategory(cat); setVisibleCount(60); }}
                                >
                                    {cat.toUpperCase()}
                                </button>
                            ))}
                        </div>
                    </div>
                    
                    <div className="filters-right">
                        <div className="legend-box">
                            <div className="legend-item"><span className="dot-leg mission"></span>MISSION</div>
                            <div className="legend-item"><span className="dot-leg enemy"></span>ENEMY</div>
                            <div className="legend-item"><span className="dot-leg shop"></span>SHOP</div>
                        </div>

                        <div className="search-wrapper">
                            <input 
                                type="text" className="search-input" placeholder="SEARCH..." 
                                value={searchTerm} onChange={(e) => setSearchTerm(e.target.value.toLowerCase())} 
                            />
                        </div>

                        <select 
                            className="search-input" 
                            style={{width:'auto', cursor:'pointer'}}
                            value={currentSort}
                            onChange={(e) => setCurrentSort(e.target.value)}
                        >
                            <option value="name">NAME</option>
                            <option value="rarity">RARITY</option>
                            <option value="drain">COST</option>
                            <option value="chance">DROP %</option>
                        </select>

                        <label className="toggle-filter">
                            <input type="checkbox" style={{display:'none'}} checked={showMissingOnly} onChange={(e) => setShowMissingOnly(e.target.checked)} />
                            <div className="checkbox-custom">{showMissingOnly && '✓'}</div>
                            MISSING
                        </label>
                    </div>
                </div>
                <div className="progress-line-container"><div className="progress-line-fill" style={{width: `${pct}%`}}></div></div>
            </div>

            <div 
                className="gallery-scroll-area" 
                onScroll={(e) => {
                    if (e.target.scrollTop + e.target.clientHeight >= e.target.scrollHeight - 500) setVisibleCount(p => p + 60);
                }}
            >
                <div className="card-gallery">
                    {filteredData.slice(0, visibleCount).map(item => (
                        <ModCard 
                            key={item.uniqueName} 
                            item={item} 
                            isOwned={ownedCards.has(item.uniqueName)} 
                            onToggle={() => toggleOwned(item.uniqueName)}
                        />
                    ))}
                </div>
            </div>
        </div>
    );
}

// --- MOD CARD COMPONENT (Stesso di prima) ---
function ModCard({ item, isOwned, onToggle }) {
    const [flipped, setFlipped] = useState(false);
    const [rank, setRank] = useState(0);
    const maxRank = item.maxRank || 0;

    const getDescription = () => {
        let desc = item.description || "";
        if (item.levelStats && item.levelStats.length > 0) {
            const statIndex = Math.min(rank, item.levelStats.length - 1);
            return item.levelStats[statIndex].stats.join('<br>');
        }
        return desc.replace(/(\d+(\.\d+)?)/g, (match) => {
            const maxVal = parseFloat(match);
            const baseVal = maxVal / (maxRank + 1);
            const currentVal = baseVal * (rank + 1);
            return currentVal % 1 === 0 ? currentVal.toFixed(0) : currentVal.toFixed(1).replace(/\.0$/, '');
        }).replace(/\r\n|\n/g, "<br>");
    };

    const currentDrain = (item.baseDrain || 0) + rank;
    const imgUrl = `${IMG_BASE_URL}/${item.imageName}`;
    
    const rarity = item.rarity || "Common";
    let nameColor = '#fff';
    if (rarity === 'Rare') nameColor = '#f0e68c';
    if (rarity === 'Legendary') nameColor = '#b0c9ec';
    if (item.category === 'Arcanes') nameColor = '#00ffcc';

    const openWiki = (e) => {
        e.stopPropagation();
        const safeName = item.name.replace(/ /g, '_');
        window.open(`https://warframe.fandom.com/wiki/${safeName}`, '_blank');
    };

    const renderDrops = () => {
        if (!item.drops || item.drops.length === 0) return <div className="mod-no-drop">Source Unknown / Quest / Market</div>;
        const getDropType = (d) => d.location.includes("Rot") || d.type?.includes("Mission") ? 'mission' : 'enemy';
        return item.drops.slice(0, 8).map((d, i) => {
            const type = getDropType(d);
            const barColor = type === 'mission' ? 'var(--mission)' : 'var(--enemy)';
            
            return (
                <div key={i} className="mod-drop-row">
                    <div className="mod-drop-header">
                        <span className="mod-drop-loc">
                            <span className={`dot-leg ${type}`} style={{display:'inline-block', marginRight:'5px'}}></span>
                            {d.location}
                        </span>
                        <span className="mod-drop-pct">{(d.chance * 100).toFixed(2)}%</span>
                    </div>
                    <div className="mod-drop-bar-bg">
                        <div className="mod-drop-bar-fill" style={{width:`${Math.min(100, d.chance * 100 * 4)}%`, background: barColor}}></div>
                    </div>
                </div>
            );
        });
    };

    return (
        <div 
            className={`mod-card-wrapper ${isOwned ? 'owned' : ''} ${flipped ? 'flipped' : ''}`}
            data-rarity={rarity}
            onClick={() => setFlipped(!flipped)}
        >
            <div className="mod-card-inner">
                {/* FRONT */}
                <div className="mod-card-front">
                    <div className="mod-owned-check" onClick={(e) => { e.stopPropagation(); onToggle(); }}>
                        {isOwned ? '✔' : '+'}
                    </div>
                    <div className="mod-drain-box">
                        {currentDrain} {item.polarity && <span style={{fontSize:'10px'}}>{item.polarity.substring(0,1)}</span>}
                    </div>
                    
                    <div className="mod-card-img-container">
                        <img 
                            src={imgUrl} 
                            className="mod-card-img" 
                            alt={item.name} 
                            loading="lazy" 
                            onError={(e)=>{e.target.style.display='none';}} 
                        />
                    </div>

                    <div className="mod-info-area">
                        <div className="mod-type-pill">{item.type}</div>
                        <div className="mod-name" style={{color: nameColor}}>{item.name}</div>
                        <div className="mod-desc" dangerouslySetInnerHTML={{__html: getDescription()}}></div>

                        {maxRank > 0 && (
                            <div className="mod-rank-controls" onClick={(e) => e.stopPropagation()}>
                                <button className="mod-rank-btn" onClick={() => setRank(Math.max(0, rank - 1))}>-</button>
                                <div className="mod-ranks-dots">
                                    {Array.from({length: maxRank + 1}).map((_, i) => (
                                        <div key={i} className={`mod-dot ${i <= rank && i > 0 ? 'active' : ''}`}></div>
                                    ))}
                                </div>
                                <button className="mod-rank-btn" onClick={() => setRank(Math.min(maxRank, rank + 1))}>+</button>
                            </div>
                        )}
                    </div>
                </div>

                {/* BACK */}
                <div className="mod-card-back">
                    <div className="mod-back-header">
                        <div className="mod-back-title">ACQUISITION</div>
                        {item.tradable && <span className="mod-trade-badge">TRADE</span>}
                    </div>
                    <div className="mod-source-content">
                        {renderDrops()}
                    </div>
                    <div className="mod-wiki-btn" onClick={openWiki}>
                        OPEN WIKI
                    </div>
                </div>
            </div>
        </div>
    );
}

==================================================
FILE: src\app\mods\page.js
==================================================

import { fetchGameData } from '@/utils/serverData';
import ModsClientPage from './ModsClientPage';

export default async function Page() {
    // Caricamento Server-Side in parallelo
    const [modsData, arcanesData] = await Promise.all([
        fetchGameData('Mods.json'),
        fetchGameData('Arcanes.json')
    ]);

    const combined = [...modsData, ...arcanesData];

    return (
        <ModsClientPage initialData={combined} />
    );
}

==================================================
FILE: src\app\necramechs\page.js
==================================================

import { fetchGameData } from '@/utils/serverData';
import CodexListPage from '@/components/CodexListPage';

export default async function Page() {
    const data = await fetchGameData('Warframes.json');

    return (
        <CodexListPage 
            initialData={data} 
            pageTitle="NECRAMECHS" 
            categoryMode="necramechs"
        />
    );
}

==================================================
FILE: src\app\not-found.js
==================================================

// src/app/not-found.js
import Link from 'next/link';

export default function NotFound() {
  return (
    <div style={{
      height: '100vh', 
      display: 'flex', 
      flexDirection: 'column', 
      alignItems: 'center', 
      justifyContent: 'center', 
      color: 'white', 
      textAlign: 'center'
    }}>
      <h1 style={{fontSize: '40px', color: '#d4af37'}}>404 - ORDIS NOT FOUND</h1>
      <p>Operator, this coordinates do not exist.</p>
      <Link href="/" style={{marginTop:'20px', color:'#3b82f6', textDecoration:'underline'}}>
        Return to Orbiter (Home)
      </Link>
    </div>
  );
}

==================================================
FILE: src\app\page.js
==================================================

"use client";
import Link from 'next/link';
import { useState, useEffect } from 'react';
import { API_BASE_URL, IMG_BASE_URL } from '@/utils/constants';
import './homepage.css';

// CONFIGURAZIONE CATEGORIE
const CATEGORIES = [
    { id: 'warframes', title: 'Warframes', subtitle: 'The Arsenal', color: '#d4af37', link: '/warframes', jsonFile: 'Warframes.json' },
    { id: 'primary', title: 'Primary', subtitle: 'Rifles & Bows', color: '#ff6b6b', link: '/primary', jsonFile: 'Primary.json' },
    { id: 'secondary', title: 'Secondary', subtitle: 'Pistols', color: '#ff9f43', link: '/secondary', jsonFile: 'Secondary.json' },
    { id: 'melee', title: 'Melee', subtitle: 'Blades & Whips', color: '#feca57', link: '/melee', jsonFile: 'Melee.json' },
    { id: 'mods', title: 'Mods', subtitle: 'Upgrades', color: '#54a0ff', link: '/mods', jsonFile: 'Mods.json' },
    { id: 'relics', title: 'Relics', subtitle: 'Void Fissures', color: '#00d2d3', link: '/relics', jsonFile: 'Relics.json' },
    { id: 'companions', title: 'Companions', subtitle: 'Sentinels', color: '#1dd1a1', link: '/companions', jsonFile: 'Sentinels.json' },
    { id: 'amps', title: 'Amps', subtitle: 'Void Weapons', color: '#a29bfe', link: '/amps', jsonFile: 'Amps.json' }
];

function ApiImageCard({ cat }) {
    const [imgUrl, setImgUrl] = useState(null);

    useEffect(() => {
        let isMounted = true;
        async function fetchImage() {
            try {
                // Fetch corretta usando API_BASE_URL aggiornato
                const res = await fetch(`${API_BASE_URL}/${cat.jsonFile}`);
                if (!res.ok) return;
                const data = await res.json();
                
                let targetItem;
                if (cat.id === 'relics') {
                    targetItem = data.find(item => item.imageName && item.name.includes('Intact'));
                } else {
                    targetItem = data.find(item => item.name.includes("Prime") && item.imageName);
                }
                
                const firstValid = targetItem || data.find(item => item.imageName && !item.imageName.includes("fanart"));
                
                if (firstValid && isMounted) {
                    // Immagine corretta usando IMG_BASE_URL aggiornato
                    setImgUrl(`${IMG_BASE_URL}/${firstValid.imageName}`);
                }
            } catch (e) { 
                console.error(`Img error ${cat.id}`, e); 
            }
        }
        fetchImage();
        return () => { isMounted = false; };
    }, [cat.jsonFile, cat.id]);

    return (
        <Link href={cat.link} style={{textDecoration:'none'}}>
            <div 
                className="menu-card"
                style={{ '--card-color': cat.color, '--card-glow': `${cat.color}66` }}
            >
                <div className="card-visual-area">
                    {imgUrl ? (
                        <img src={imgUrl} alt={cat.title} className="card-img-element" />
                    ) : (
                        <div style={{background:'#151518', width:'100%', height:'100%'}}></div>
                    )}
                </div>
                
                <div className="card-content">
                    <h2 className="card-title">{cat.title}</h2>
                    <p className="card-sub">{cat.subtitle}</p>
                </div>
            </div>
        </Link>
    );
}

export default function LandingPage() {
    return (
        <main className="landing-page">
            <div className="landing-content">
                <div className="landing-header">
                    <h1 className="landing-title">ORDIS CODEX</h1>
                    <div className="landing-subtitle">Tracker & Database System</div>
                </div>

                <div className="cards-scroll-container">
                    <div className="cards-row">
                        {CATEGORIES.map((cat) => (
                            <ApiImageCard key={cat.id} cat={cat} />
                        ))}
                    </div>
                </div>
                
                <div className="landing-footer">
                    Operator Interface v2.0 // System Ready
                </div>
            </div>
        </main>
    );
}

==================================================
FILE: src\app\primary\page.js
==================================================

import { fetchGameData } from '@/utils/serverData';
import CodexListPage from '@/components/CodexListPage';

export default async function Page() {
    const [data, lookup] = await Promise.all([
        fetchGameData('Primary.json'),
        fetchGameData('RelicLookup.json')
    ]);

    return (
        <CodexListPage 
            initialData={data} 
            lookupData={lookup}
            pageTitle="PRIMARY WEAPONS" 
            categoryMode="primary"
        />
    );
}

==================================================
FILE: src\app\relics\page.js
==================================================

import { fetchGameData } from '@/utils/serverData';
import CodexListPage from '@/components/CodexListPage';

export default async function Page() {
    const data = await fetchGameData('Relics.json');

    return (
        <CodexListPage 
            initialData={data} 
            pageTitle="VOID RELICS" 
            categoryMode="relics"
        />
    );
}

==================================================
FILE: src\app\secondary\page.js
==================================================

import { fetchGameData } from '@/utils/serverData';
import CodexListPage from '@/components/CodexListPage';

export default async function Page() {
    const [data, lookup] = await Promise.all([
        fetchGameData('Secondary.json'),
        fetchGameData('RelicLookup.json')
    ]);

    return (
        <CodexListPage 
            initialData={data} 
            lookupData={lookup}
            pageTitle="SECONDARY WEAPONS" 
            categoryMode="secondary"
        />
    );
}

==================================================
FILE: src\app\warframes\page.js
==================================================

import { fetchGameData } from '@/utils/serverData';
import CodexListPage from '@/components/CodexListPage';

export default async function Page() {
    const [data, lookup] = await Promise.all([
        fetchGameData('Warframes.json'),
        fetchGameData('RelicLookup.json')
    ]);

    return (
        <CodexListPage 
            initialData={data} 
            lookupData={lookup}
            pageTitle="WARFRAMES" 
            categoryMode="warframes" // Passiamo solo la stringa!
        />
    );
}

==================================================
FILE: src\components\CodexCard.js
==================================================

"use client";
import { useState, memo } from 'react';
import { IMG_BASE_URL } from '@/utils/constants';

const getStatAtRank = (rank, maxRank, descriptionTemplate, levelStats) => {
    if (levelStats && levelStats.length > 0) {
        let statsArray = levelStats[rank] ? levelStats[rank].stats : levelStats[levelStats.length - 1].stats;
        return statsArray.join('<br>');
    }
    if (!descriptionTemplate) return "";
    return descriptionTemplate.replace(/(\d+(\.\d+)?)/g, (match) => {
        const maxVal = parseFloat(match);
        const baseVal = maxVal / (maxRank + 1);
        const currentVal = baseVal * (rank + 1);
        return currentVal % 1 === 0 ? currentVal.toFixed(0) : currentVal.toFixed(1).replace(/\.0$/, '');
    }).replace(/\r\n|\n/g, "<br>");
};

const CodexCard = memo(function CodexCard({ item, isOwned, onToggleOwned }) {
    const [rank, setRank] = useState(item.maxRank || 0);

    const isMod = item.category === 'Mods';
    const isArcane = item.category === 'Arcanes';
    const isPrime = item.name.includes("Prime");
    
    // --- LOGICA PURA: SI BASA SOLO SUL DATO SCRITTO ---
    const isVaulted = !!item.vaulted;

    const updateRank = (e, change) => {
        e.stopPropagation();
        let newRank = rank + change;
        if (newRank < 0) newRank = 0;
        if (newRank > item.maxRank) newRank = item.maxRank;
        setRank(newRank);
    };

    let displayDesc = item.description || "Nessuna descrizione.";
    if (isMod || isArcane) {
        displayDesc = getStatAtRank(rank, item.maxRank, item.rawDescription || item.description, item.levelStats);
    }
    
    displayDesc = displayDesc.replace(/<br>/g, " <br/> ");

    return (
        <div className={`card-wrapper ${isOwned ? 'owned' : ''}`} data-rarity={item.rarity || (isPrime ? 'Prime' : 'Common')}>
            
            <div className="card-image-container">
                <div className="owned-check" onClick={(e) => { e.stopPropagation(); onToggleOwned(item.uniqueName); }}>
                    {isOwned ? '✔' : ''}
                </div>

                {/* Mostra ETICHETTA solo se il dato dice che è Vaulted */}
                {isVaulted && <div className="vaulted-tag-card">VAULTED</div>}

                {(item.baseDrain || item.polarityIcon) && (isMod || isArcane) && (
                    <div className="drain-box">
                        {item.baseDrain ? (item.baseDrain + rank) : ""}
                        {item.polarityIcon && <img src={item.polarityIcon} className="polarity-icon" alt="pol" />}
                    </div>
                )}

                {item.imageName ? (
                    <img 
                        src={`${IMG_BASE_URL}/${item.imageName}`} 
                        className="card-image-img" 
                        loading="lazy" 
                        alt={item.name}
                        style={isArcane ? { transform: 'scale(0.7)' } : {}} 
                    />
                ) : <div style={{fontSize:'10px', color:'#666'}}>{item.name}</div>}
            </div>

            <div className="info-area">
                <div className="type-pill">{item.type}</div>
                <div className="mod-name" style={{color: isPrime ? 'var(--gold)' : '#fff'}}>
                    {item.name}
                </div>
                
                <div className="card-desc" dangerouslySetInnerHTML={{__html: displayDesc}}></div>

                {(isMod || isArcane) && item.maxRank > 0 && (
                    <div className="rank-controls-container">
                        <button className="rank-btn" onClick={(e) => updateRank(e, -1)}>-</button>
                        <div className="ranks-dots">
                            {Array.from({length: Math.min(item.maxRank + 1, 10)}).map((_, i) => (
                                <div key={i} className={`dot ${i <= (rank / item.maxRank * Math.min(item.maxRank, 9)) ? 'active' : ''}`}></div>
                            ))}
                        </div>
                        <button className="rank-btn" onClick={(e) => updateRank(e, 1)}>+</button>
                    </div>
                )}

                <a href={`https://warframe.fandom.com/wiki/${item.name.replace(/ /g, '_')}`} target="_blank" className="wiki-btn-block" onClick={(e) => e.stopPropagation()}>
                    WIKI
                </a>
            </div>
        </div>
    );
});

export default CodexCard;

==================================================
FILE: src\components\CodexListPage.js
==================================================

"use client";
import { useState, useEffect, useMemo, Suspense } from 'react';
import { useRouter, usePathname, useSearchParams } from 'next/navigation';
import Link from 'next/link';
import CodexCard from './CodexCard';
import dynamic from 'next/dynamic';
import { useOwnedItems } from '@/hooks/useOwnedItems';
import { CATEGORY_CONFIGS } from '@/utils/clientCategories'; // IMPORTA LE CATEGORIE QUI
import '@/app/hud-layout.css'; 

const WarframeDetailModal = dynamic(() => import('./WarframeDetailModal'), {
    loading: () => <div style={{position:'fixed', inset:0, zIndex:2000, display:'flex', alignItems:'center', justifyContent:'center', background:'rgba(0,0,0,0.8)', color:'white'}}>Loading Interface...</div>,
    ssr: false
});

function CodexContent({ pageTitle, categoryMode, initialData = [], lookupData = null }) {
    // categoryMode è una stringa (es: "warframes", "primary")
    
    // Recupera la configurazione corretta dal file client
    const customCategories = categoryMode ? CATEGORY_CONFIGS[categoryMode] : null;

    const [rawApiData, setRawApiData] = useState([]);
    const [loading, setLoading] = useState(true);
    
    const searchParams = useSearchParams();
    const router = useRouter();
    const pathname = usePathname();
    const { ownedCards, toggleOwned } = useOwnedItems();
    const [selectedItem, setSelectedItem] = useState(null);

    const defaultCat = customCategories ? customCategories[0].id : 'all';
    const subCategory = searchParams.get('sub') || defaultCat;
    const [activeSubFilter, setActiveSubFilter] = useState('all');
    
    const [searchTerm, setSearchTerm] = useState("");
    const [debouncedSearch, setDebouncedSearch] = useState("");

    const [showMissingOnly, setShowMissingOnly] = useState(false);
    const [hideVaulted, setHideVaulted] = useState(false);
    const [visibleCount, setVisibleCount] = useState(60);

    const activeConfig = customCategories ? customCategories.find(c => c.id === subCategory) : null;

    useEffect(() => {
        const timer = setTimeout(() => {
            setDebouncedSearch(searchTerm);
        }, 300);
        return () => clearTimeout(timer);
    }, [searchTerm]);

    // Processamento Iniziale Dati
    useEffect(() => {
        if (initialData) {
            const activeRelicsSet = new Set(lookupData ? Object.keys(lookupData) : []);
            
            const processed = initialData
                .filter(i => i && !i.uniqueName.includes("RANDOM") && i.imageName) 
                .map(item => {
                    let computedVaulted = !!item.vaulted; 

                    if (item.name.includes('Prime') && lookupData) {
                        const relicNames = [];
                        if (item.components) {
                            item.components.forEach(c => {
                                if(c.drops) c.drops.forEach(d => {
                                    const match = d.location.toUpperCase().match(/(LITH|MESO|NEO|AXI|REQUIEM)\s+([A-Z0-9]+)/);
                                    if (match) relicNames.push(`${match[1]} ${match[2]}`);
                                });
                            });
                        }
                        
                        if (relicNames.length > 0) {
                            const hasActiveRelic = relicNames.some(r => activeRelicsSet.has(r));
                            if (!hasActiveRelic) computedVaulted = true; 
                            else computedVaulted = false; 
                        }
                    }

                    return {
                        ...item,
                        vaulted: computedVaulted, 
                        maxRank: item.fusionLimit || item.maxLevel || 30,
                        baseDrain: item.baseDrain || 0,
                        polarityIcon: item.polarity ? `https://warframe.fandom.com/wiki/File:Polarity_${item.polarity.charAt(0).toUpperCase() + item.polarity.slice(1)}.png` : null 
                    };
                });

            const uniqueItems = Array.from(new Map(processed.map(item => [item.name, item])).values());
            uniqueItems.sort((a, b) => a.name.localeCompare(b.name));
            
            setRawApiData(uniqueItems);
            setLoading(false);
        }
    }, [initialData, lookupData]);

    const processedData = useMemo(() => {
        return rawApiData.filter(item => {
            if (debouncedSearch && !item.name.toLowerCase().includes(debouncedSearch)) return false;
            if (showMissingOnly && ownedCards.has(item.uniqueName)) return false;
            if (hideVaulted && item.vaulted) return false;
            
            if (activeConfig && activeConfig.filter && !activeConfig.filter(item)) return false;
            if (activeConfig && activeConfig.subFilters) {
                const subLogic = activeConfig.subFilters.find(sf => sf.id === activeSubFilter);
                if (subLogic && subLogic.filter && !subLogic.filter(item)) return false;
            }
            return true;
        });
    }, [rawApiData, subCategory, activeSubFilter, debouncedSearch, showMissingOnly, hideVaulted, ownedCards, activeConfig]);

    const handleCategoryChange = (id) => {
        const p = new URLSearchParams(searchParams.toString());
        p.set('sub', id);
        router.push(`${pathname}?${p.toString()}`);
        setActiveSubFilter('all'); 
    };

    if (loading) return <div style={{padding:'50px', color:'#fff', textAlign:'center'}}>INITIALIZING ORDIS DATABASE...</div>;

    const pct = rawApiData.length > 0 ? Math.round((ownedCards.size / rawApiData.length) * 100) : 0;

    return (
        <div className="codex-layout">
            <div className="header-group">
                <div className="nav-top-row">
                    <div className="nav-brand">
                        <Link href="/" className="nav-home-btn">⌂ HOME</Link>
                        <h1 className="page-title">{pageTitle}</h1>
                    </div>
                    <div className="stats-right">
                        <div className="stat-box">
                            <div className="stat-label">COLLECTED</div>
                            <div className="stat-value"><span>{ownedCards.size}</span> / {rawApiData.length}</div>
                        </div>
                        <div className="stat-box">
                            <div className="stat-label">COMPLETION</div>
                            <div className="stat-value">{pct}%</div>
                        </div>
                    </div>
                </div>

                <div className="controls-row">
                    <div className="filters-left">
                        {customCategories && customCategories.length > 1 && (
                            <div className="category-tabs">
                                {customCategories.map(c => (
                                    <button key={c.id} className={`tab-btn ${subCategory === c.id ? 'active' : ''}`} onClick={() => handleCategoryChange(c.id)}>
                                        {c.label}
                                    </button>
                                ))}
                            </div>
                        )}
                         {activeConfig && activeConfig.subFilters && (
                            <div className="category-tabs">
                                {activeConfig.subFilters.map(sf => (
                                    <button key={sf.id} onClick={() => setActiveSubFilter(sf.id)} className={`tab-btn ${activeSubFilter === sf.id ? 'active' : ''}`}>
                                        {sf.label}
                                    </button>
                                ))}
                            </div>
                        )}
                    </div>
                    
                    <div className="filters-right">
                         <div className="search-wrapper">
                            <input type="text" className="search-input" placeholder="SEARCH..." value={searchTerm} onChange={(e) => setSearchTerm(e.target.value.toLowerCase())} />
                        </div>
                        <label className="toggle-filter">
                            <input type="checkbox" style={{display:'none'}} checked={hideVaulted} onChange={(e) => setHideVaulted(e.target.checked)} />
                            <div className="checkbox-custom">{hideVaulted && '✓'}</div>
                            HIDE VAULTED
                        </label>
                        <label className="toggle-filter">
                            <input type="checkbox" style={{display:'none'}} checked={showMissingOnly} onChange={(e) => setShowMissingOnly(e.target.checked)} />
                            <div className="checkbox-custom">{showMissingOnly && '✓'}</div>
                            MISSING
                        </label>
                    </div>
                </div>
                <div className="progress-line-container"><div className="progress-line-fill" style={{width: `${pct}%`}}></div></div>
            </div>

             <div className="gallery-scroll-area" onScroll={(e) => {
                if (e.target.scrollTop + e.target.clientHeight >= e.target.scrollHeight - 500) setVisibleCount(p => p + 60);
            }}>
                <div className="card-gallery">
                    {processedData.slice(0, visibleCount).map(item => (
                        <div key={item.uniqueName} onClick={() => setSelectedItem(item)} style={{cursor:'pointer'}}>
                            <CodexCard item={item} isOwned={ownedCards.has(item.uniqueName)} onToggleOwned={toggleOwned} />
                        </div>
                    ))}
                </div>
            </div>
            {selectedItem && (
                <WarframeDetailModal item={selectedItem} onClose={() => setSelectedItem(null)} ownedItems={ownedCards} onToggle={toggleOwned} />
            )}
        </div>
    );
}

export default function CodexListPage(props) {
    return (
        <Suspense fallback={<div style={{color:'#fff', padding:'50px', textAlign:'center'}}>Loading Interface...</div>}>
            <CodexContent {...props} />
        </Suspense>
    );
}

==================================================
FILE: src\components\WarframeDetailModal.css
==================================================

/* src/components/WarframeDetailModal.css */

/* SFONDO MODALE */
.modal-overlay { 
  position: fixed; inset: 0; 
  background: rgba(0, 0, 0, 0.95); backdrop-filter: blur(10px); 
  z-index: 2000; /* Z-Index altissimo */
  display: flex; align-items: center; justify-content: center; 
  padding: 20px;
}

/* CONTENITORE PRINCIPALE */
.modal-content-simple { 
  width: 100%; max-width: 1600px; height: 90vh; 
  background: #121214; border: 1px solid #333; border-top: 3px solid var(--gold);
  display: flex; flex-direction: row; /* Desktop: Orizzontale */
  overflow: hidden; position: relative; 
  box-shadow: 0 0 50px #000; border-radius: 4px;
}

/* PULSANTE CHIUSURA - Posizione assoluta ma sicura */
.close-btn { 
  position: absolute; top: 10px; right: 15px; 
  color: #fff; font-size: 32px; background: rgba(0,0,0,0.6); 
  border: 1px solid #444; border-radius: 50%;
  width: 40px; height: 40px; display: flex; align-items: center; justify-content: center;
  cursor: pointer; z-index: 3000; /* Sopra a tutto */
  padding-bottom: 4px; /* Centratura visiva */
}
.close-btn:hover { color: var(--gold); border-color: var(--gold); background: #000; }

.modal-header-row { display: none; } /* Nascondiamo header legacy */
.modal-body { display: flex; width: 100%; height: 100%; }

/* --- STILI DESKTOP (3 COLONNE) --- */
.col-left { 
  flex: 0 0 320px; background: #0a0a0c; border-right: 1px solid #333; 
  display: flex; flex-direction: column; padding: 30px; overflow-y: auto;
}
.col-center { 
  flex: 0 0 35%; background: #121214; border-right: 1px solid #333; 
  display: flex; flex-direction: column; overflow-y: auto;
}
.col-right { 
  flex: 1; background: #0e0e10; display: flex; flex-direction: column; overflow-y: auto;
}

/* CONTENUTI */
.det-title { font-size: 32px; font-weight: 900; color: #fff; margin: 0; text-transform: uppercase; line-height: 1; }
.det-subtitle { color: var(--gold); font-size: 14px; font-weight: bold; margin-bottom: 20px; text-transform: uppercase; letter-spacing: 1px; }

.det-img-box { 
    width: 100%; height: 300px; 
    display: flex; align-items: center; justify-content: center; 
    margin-bottom: 20px; position: relative;
}
.det-img-box img { 
    max-width: 100%; max-height: 100%; 
    object-fit: contain; /* Fondamentale per non tagliare l'immagine */
    filter: drop-shadow(0 0 20px rgba(0,0,0,0.5)); 
}

.det-desc { font-size: 13px; color: #888; line-height: 1.5; margin-bottom: 20px; max-height: 200px; overflow-y: auto; }

/* HEADER COLONNE */
.col-header { 
  padding: 15px 20px; background: #1a1a1e; border-bottom: 1px solid #333; 
  font-size: 14px; font-weight: 800; color: #fff; letter-spacing: 1px; text-transform: uppercase;
  display: flex; justify-content: space-between; align-items: center; flex-shrink: 0;
}
.col-scrollable { flex: 1; overflow-y: auto; padding: 20px; }

/* COMPONENTI & CARDS */
.component-row { margin-bottom: 20px; }
.component-header { display: flex; align-items: center; gap: 10px; background: #18181b; padding: 8px; border: 1px solid #333; margin-bottom: 8px; border-radius: 4px; }
.component-icon { width: 30px; height: 30px; position: relative; }
.component-icon img { width: 100%; height: 100%; object-fit: contain; }
.count-badge { font-size: 10px; background: #000; padding: 2px 6px; border-radius: 4px; border: 1px solid #333; color: #666; margin-left: auto; }

.relic-cards-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(130px, 1fr)); gap: 10px; }
.mini-relic-card { 
  background: #1a1a1d; border: 1px solid #333; border-radius: 4px; padding: 8px; 
  display: flex; flex-direction: row; align-items: center; gap: 10px; 
  cursor: pointer; position: relative;
}
.mini-relic-card:hover { border-color: #666; background: #222; }
.mini-relic-card.selected { border-color: var(--gold); background: rgba(212, 175, 55, 0.08); }
.relic-card-img { width: 30px; height: 30px; object-fit: contain; }
.card-info { display: flex; flex-direction: column; overflow: hidden; }
.card-name { font-size: 11px; color: #fff; font-weight: 700; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.card-pct { font-size: 10px; font-weight: 600; }
.pct-common { color: #cd7f32; }
.pct-uncommon { color: #c0c0c0; }
.pct-rare { color: var(--gold); text-shadow: 0 0 5px rgba(212,175,55,0.4); }

.strategy-container { display: flex; flex-direction: column; gap: 15px; }
.mission-block { background: #121215; border: 1px solid #2a2a2e; border-radius: 4px; overflow: hidden; }
.mission-block-header { background: #18181b; padding: 10px 15px; border-bottom: 1px solid #222; display: flex; justify-content: space-between; align-items: center; }
.mission-name-large { font-size: 13px; font-weight: bold; color: #fff; }
.mission-relics-table { width: 100%; border-collapse: collapse; }
.mission-relics-table td { padding: 10px 15px; border-bottom: 1px solid #1f1f22; font-size: 12px; color: #bbb; }
.part-badge { display: inline-block; background: rgba(95, 255, 165, 0.08); border: 1px solid rgba(95, 255, 165, 0.2); color: #5fffa5; padding: 2px 6px; border-radius: 3px; font-size: 9px; font-weight: 700; text-transform: uppercase; }

.btn-toggle-large {
  width: 100%; padding: 15px; margin-top: 20px;
  background: var(--gold); color: #000; font-weight: 800; letter-spacing: 1px;
  border: none; border-radius: 2px; cursor: pointer; text-transform: uppercase;
}
.btn-toggle-large.owned { background: #222; color: #fff; border: 1px solid #444; }
.wiki-btn-block { 
  display: block; width: 100%; margin-top: 15px; padding: 10px;
  background: transparent; text-align: center; font-size: 11px; font-weight: 800; 
  color: #666; border: 1px solid #333; text-transform: uppercase; text-decoration: none; 
}
.vault-badge { font-size: 10px; padding: 4px 10px; border-radius: 2px; font-weight: bold; text-transform: uppercase; letter-spacing: 1px; }
.vault-badge.is-vaulted { background: rgba(255, 50, 50, 0.1); color: #ff5555; border: 1px solid rgba(255, 50, 50, 0.3); }
.vault-badge.is-available { background: rgba(50, 255, 100, 0.05); color: #5fffa5; border: 1px solid rgba(50, 255, 100, 0.2); }
.base-mission-table { width: 100%; border-collapse: collapse; }
.base-mission-table td { padding: 8px 12px; border-bottom: 1px solid #1a1a1e; font-size: 11px; }

/* =========================================
   MEDIA QUERIES - MOBILE TRANSFORMATION
   ========================================= */

@media (max-width: 1024px) {
  .modal-overlay {
    padding: 0;
    align-items: flex-start; /* Allinea in alto */
    overflow-y: auto; /* Permette lo scroll dell'overlay */
  }

  .modal-content-simple {
    width: 100%;
    min-height: 100vh; /* Occupa tutto lo schermo */
    height: auto;
    max-height: none;
    border: none;
    border-radius: 0;
    flex-direction: column; /* COLONNA VERTICALE */
    box-shadow: none;
    overflow: visible; /* Lascia che il contenuto allunghi la pagina */
  }
  
  .modal-body {
    flex-direction: column;
    height: auto;
    overflow: visible;
  }

  .close-btn {
    top: 15px; right: 15px;
    background: #000; border: 1px solid var(--gold);
    color: var(--gold);
    position: fixed; /* FISSO SULLO SCHERMO */
  }

  /* Reset delle colonne per Mobile */
  .col-left, .col-center, .col-right {
    flex: none; 
    width: 100%;
    height: auto;
    border-right: none;
    border-bottom: 1px solid #333;
    padding: 20px;
    overflow: visible;
  }
  
  .col-left { order: 1; background: #050505; padding-top: 60px; /* Spazio per il bottone di chiusura */ }
  .col-center { order: 2; background: #121214; }
  .col-right { order: 3; background: #0e0e10; padding-bottom: 100px; }

  /* Aggiustamenti Immagine Mobile */
  .det-img-box {
    height: 300px; /* Altezza fissa ma contenuta */
    margin-top: 10px;
  }
  .det-title { font-size: 28px; }

  /* Nascondi colonna destra se in base mode */
  .modal-content-simple.base-mode .col-right { display: none; }
}

==================================================
FILE: src\components\WarframeDetailModal.js
==================================================

"use client";
import React, { useEffect, useState } from 'react';
import { IMG_BASE_URL, API_BASE_URL } from '@/utils/constants';
import './WarframeDetailModal.css';

const HIDDEN_RESOURCES = [
    'Orokin Cell', 'Argon Crystal', 'Neural Sensors', 'Neurodes', 
    'Plastids', 'Rubedo', 'Ferrite', 'Alloy Plate', 'Polymer Bundle', 
    'Circuits', 'Salvage', 'Morphics', 'Control Module', 'Gallium', 
    'Nitain Extract', 'Tellurium', 'Cryotic', 'Oxium'
];

export default function WarframeDetailModal({ item, onClose, ownedItems, onToggle }) {
    const [smartMissions, setSmartMissions] = useState([]); 
    const [baseStrategies, setBaseStrategies] = useState([]); 
    const [lookupData, setLookupData] = useState(null); 
    const [savedPartMap, setSavedPartMap] = useState({});
    
    const [selectedRelics, setSelectedRelics] = useState(new Set());
    const [loadingStrategies, setLoadingStrategies] = useState(false);
    const [statusMsg, setStatusMsg] = useState(""); 

    if (!item) return null;

    const isOwned = ownedItems.has(item.uniqueName);
    const isRelicItem = (item.category || "").includes('Relic') || (item.type || "").includes('Relic');
    const isPrime = item.name.includes("Prime");
    
    // Logica Vaulted
    const jsonVaulted = !!item.vaulted;
    const computedVaulted = !isRelicItem && !loadingStrategies && smartMissions.length === 0 && baseStrategies.length === 0;
    const isVaulted = jsonVaulted || (isPrime && computedVaulted); 

    const wikiUrl = `https://warframe.fandom.com/wiki/${item.name.replace(/ /g, '_')}`;

    useEffect(() => {
        const handleEsc = (e) => { if (e.key === 'Escape') onClose(); };
        window.addEventListener('keydown', handleEsc);
        setSelectedRelics(new Set()); 
        
        if (!isRelicItem && (item.components || item.drops)) {
            fetchFarmingData();
        } else {
            setLoadingStrategies(false);
        }
        return () => window.removeEventListener('keydown', handleEsc);
    }, [onClose, item]);

    // --- UTILS ---
    function getStandardID(name) {
        if (!name) return null;
        const match = name.toUpperCase().match(/(LITH|MESO|NEO|AXI|REQUIEM)\s+([A-Z0-9]+)/);
        if (match) return `${match[1]} ${match[2]}`;
        return null;
    }

    function getCleanPartName(fullComponentName) {
        if (!fullComponentName || fullComponentName === "MAIN BP") return "MAIN BP";
        const safeItemName = item.name.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); 
        const nameRegex = new RegExp(safeItemName, "gi");
        let clean = fullComponentName.replace(nameRegex, "").replace(/Blueprint/gi, "").replace(/Relic/gi, "").trim();
        if (fullComponentName.match(/Chassis/i)) return "CHASSIS";
        if (fullComponentName.match(/Systems/i)) return "SYSTEMS";
        if (fullComponentName.match(/Neuroptics/i)) return "NEURO";
        if (fullComponentName.match(/Harness/i)) return "HARNESS";
        if (fullComponentName.match(/Wings/i)) return "WINGS";
        if (!clean || clean.length < 2) return "MAIN BP";
        return clean.toUpperCase();
    }

    const handleRelicClick = (relicId) => {
        if (!relicId) return;
        const newSet = new Set(selectedRelics);
        if (newSet.has(relicId)) newSet.delete(relicId);
        else newSet.add(relicId);
        setSelectedRelics(newSet);
    };

    // --- CALCOLATORE STRATEGIA ---
    function calculateMissionsStrategy(relicIdsSet, dbData, partMap) {
        const missionMap = new Map();
        relicIdsSet.forEach(relicID => {
            if (relicID.startsWith("DIRECT:")) return; 
            const relicInfo = dbData ? dbData[relicID] : null; 
            const missions = relicInfo ? (Array.isArray(relicInfo) ? relicInfo : relicInfo.drops) : [];
            const partName = partMap[relicID] || "PART";
            if (missions) {
                missions.forEach(mission => {
                    const key = mission.node;
                    if (!missionMap.has(key)) missionMap.set(key, { missionName: key, totalScore: 0, relicsFound: [] });
                    const entry = missionMap.get(key);
                    let relicEntry = entry.relicsFound.find(r => r.id === relicID);
                    if (!relicEntry) {
                        relicEntry = { id: relicID, part: partName, drops: [], maxChance: 0 };
                        entry.relicsFound.push(relicEntry);
                    }
                    const dropExists = relicEntry.drops.some(d => d.rot === mission.rot);
                    if (!dropExists) {
                        relicEntry.drops.push({ rot: mission.rot, chance: mission.chance });
                        if (mission.chance > relicEntry.maxChance) relicEntry.maxChance = mission.chance;
                        entry.totalScore += mission.chance;
                    }
                });
            }
        });
        return Array.from(missionMap.values()).sort((a, b) => b.totalScore - a.totalScore).slice(0, 15);
    }

    function calculateBaseStrategy(relicIdsSet) {
        const componentMap = new Map(); 
        relicIdsSet.forEach(relicID => {
            if (relicID.startsWith("DIRECT:")) {
                const info = JSON.parse(relicID.substring(7)); 
                const part = info.part; 
                if (!componentMap.has(part)) componentMap.set(part, []);
                const list = componentMap.get(part);
                if (!list.some(m => m.loc === info.loc && m.rot === info.rarity)) {
                    list.push({ loc: info.loc, rot: info.rarity || "-", chance: info.chance || 0 });
                }
            }
        });
        const strategyObj = {};
        componentMap.forEach((missions, part) => {
            strategyObj[part] = missions.sort((a, b) => b.chance - a.chance).slice(0, 5);
        });
        return strategyObj;
    }

    async function fetchFarmingData() {
        setLoadingStrategies(true);
        setStatusMsg("Analyzing...");
        try {
            const neededIDs = new Set();
            const relicToPartMap = {}; 
            
            const scan = (drops, partNameLabel) => {
                (drops || []).forEach(d => {
                    const id = getStandardID(d.location);
                    const cleanPart = getCleanPartName(partNameLabel);
                    if (id) { neededIDs.add(id); relicToPartMap[id] = cleanPart; } 
                    else {
                        const fakeID = `DIRECT:${JSON.stringify({ loc: d.location, part: cleanPart, chance: d.chance, rarity: d.rarity })}`;
                        neededIDs.add(fakeID);
                    }
                });
            };

            (item.components || []).forEach(c => { if(!HIDDEN_RESOURCES.includes(c.name)) scan(c.drops, c.name); });
            scan(item.drops, "MAIN BP");
            setSavedPartMap(relicToPartMap);

            if (neededIDs.size === 0) { setLoadingStrategies(false); return; }

            const [lookupRes, relicsRes] = await Promise.all([
                fetch(`${API_BASE_URL}/RelicLookup.json`),
                fetch(`${API_BASE_URL}/Relics.json`)
            ]);

            let lookupDB = {}; if (lookupRes.ok) lookupDB = await lookupRes.json();
            let imageMap = {};
            if (relicsRes.ok) {
                const relicsArr = await relicsRes.json();
                relicsArr.forEach(r => {
                    const stdName = getStandardID(r.name);
                    if (stdName && r.imageName) imageMap[stdName] = r.imageName;
                });
            }
            lookupDB._images = imageMap;
            setLookupData(lookupDB); 

            setSmartMissions(calculateMissionsStrategy(neededIDs, lookupDB, relicToPartMap));
            setBaseStrategies(calculateBaseStrategy(neededIDs));

        } catch (e) { console.error(e); setStatusMsg("N/A"); } finally { setLoadingStrategies(false); }
    }

    // --- RENDER HELPERS ---
    function formatDropsWithVaultCheck(drops) {
        if(!drops || drops.length === 0) return [];
        const unique = new Map();
        drops.forEach(d => {
            let loc = d.location;
            let isRelic = loc.toUpperCase().match(/(LITH|MESO|NEO|AXI|REQUIEM)\s+[A-Z0-9]+/);
            if(isRelic && loc.match(/(Radiant|Flawless|Exceptional)/i)) return; 
            if(isRelic) {
                let cleanLoc = loc.replace(' Relic', '').replace(' (Intact)', '').trim();
                let relicID = getStandardID(cleanLoc);
                let imagePath = null;
                let isVaultedRelic = false;
                
                if (lookupData && lookupData._images && lookupData._images[relicID]) {
                    imagePath = `${IMG_BASE_URL}/${lookupData._images[relicID]}`;
                } else {
                    imagePath = `${IMG_BASE_URL}/${cleanLoc.toLowerCase().replace(/ /g, '-')}-relic.png`;
                }
                if (lookupData && relicID && !lookupData[relicID]) isVaultedRelic = true;

                if(!unique.has(cleanLoc)) {
                    unique.set(cleanLoc, {
                        loc: cleanLoc, isRelic: true, imagePath, relicID, isVaultedRelic,
                        rarityClass: getRarityClass(d.rarity)
                    });
                }
            }
        });
        return Array.from(unique.values()).sort((a,b) => (a.isVaultedRelic === b.isVaultedRelic) ? 0 : a.isVaultedRelic ? 1 : -1);
    }

    // --- COSTRUZIONE LISTA COMPONENTI (FIX PRIME MAIN BP) ---
    let fullComponentsList = [];
    if (!isRelicItem) {
        // 1. Cerca se esiste un componente chiamato "Blueprint" nei dati
        const foundBpComponent = (item.components || []).find(c => c.name.toLowerCase().includes('blueprint'));
        
        // 2. Determina i drop corretti per il Main BP
        // Se c'è un componente blueprint, usiamo i suoi drop. Altrimenti usiamo i drop generali dell'item.
        const mainBpDrops = foundBpComponent ? foundBpComponent.drops : (item.drops || []);

        // 3. Aggiungi il blocco "MAIN BP" in cima alla lista
        fullComponentsList.push({
            uniqueName: item.uniqueName + "_BP",
            name: "MAIN BP",
            itemCount: 1,
            imageName: item.imageName,
            drops: mainBpDrops // Ora contiene i drop corretti anche per i Prime!
        });

        // 4. Aggiungi gli altri componenti (Escludendo "Blueprint" perché l'abbiamo appena gestito manualmente)
        const subs = (item.components || []).filter(comp => 
            !HIDDEN_RESOURCES.includes(comp.name) && 
            !comp.name.toLowerCase().includes('blueprint') 
        );
        fullComponentsList = [...fullComponentsList, ...subs];
    }
    
    const hasComponents = fullComponentsList.length > 0;
    const sortedRewards = item.rewards ? [...item.rewards].sort((a, b) => (b.chance || 0) - (a.chance || 0)) : [];

    function getRarityClass(r) {
        if(!r) return ""; r = r.toLowerCase();
        if(r.includes('rare')) return "pct-rare";
        if(r.includes('uncommon')) return "pct-uncommon";
        return "pct-common";
    }

    return (
        <div className="modal-overlay" onClick={onClose}>
            <div className={`modal-content-simple ${!isPrime && !isRelicItem ? 'base-mode' : ''}`} onClick={(e) => e.stopPropagation()}>
                <button className="close-btn" onClick={onClose}>&times;</button>

                <div className="modal-header-row">
                    <div style={{display:'flex', alignItems:'center', gap:'15px'}}>
                        <h2 className="modal-title">{item.name}</h2>
                        <div className="type-pill">{item.type}</div>
                    </div>
                    {isVaulted ? <div className="vault-badge is-vaulted">VAULTED</div> : <div className="vault-badge is-available">AVAILABLE</div>}
                </div>

                <div className="modal-body">
                    {/* COLONNA 1: INFO */}
                    <div className="col-left">
                        <div style={{width:'100%', display:'flex', justifyContent:'center', marginBottom:'20px'}}>
                            <img src={`${IMG_BASE_URL}/${item.imageName}`} alt={item.name} style={{maxWidth:'100%', maxHeight:'250px'}} onError={(e)=>e.target.style.display='none'} />
                        </div>
                        {item.description && <p className="warframe-description">{item.description}</p>}
                        <button onClick={() => onToggle(item.uniqueName)} className={`btn-toggle-large ${isOwned ? 'owned' : ''}`}>
                            {isOwned ? '✔ POSSEDUTO' : '+ AGGIUNGI'}
                        </button>
                        <a href={wikiUrl} target="_blank" rel="noopener noreferrer" className="wiki-btn-block">WIKI PAGE</a>
                    </div>

                    {/* COLONNA 2: COMPONENTI (Si espande se è Base Warframe) */}
                    <div className="col-center" style={{flex: !isPrime && !isRelicItem ? 2 : 1}}>
                        <h3 className="section-title">{isRelicItem ? "REWARDS" : "COMPONENTS & ACQUISITION"}</h3>
                        
                        {isRelicItem && (
                            <div style={{display:'flex', flexDirection:'column', gap:'5px'}}>
                                {sortedRewards.map((r, i) => (
                                    <div key={i} style={{display:'flex', justifyContent:'space-between', padding:'8px', borderBottom:'1px solid #222', fontSize:'13px'}}>
                                        <span style={{color: '#aaa'}}>{r.itemName || r.item?.name}</span>
                                        <span style={{fontWeight:'bold', color:'var(--gold)'}}>{(r.chance*100).toFixed(0)}%</span>
                                    </div>
                                ))}
                            </div>
                        )}

                        {!isRelicItem && fullComponentsList.map((comp, idx) => {
                            const cleanName = getCleanPartName(comp.name);
                            const partMissions = baseStrategies[cleanName] || [];
                            
                            return (
                                <div key={idx} className="component-row">
                                    <div className="component-header">
                                        <div className="component-icon"><img src={`${IMG_BASE_URL}/${comp.imageName}`} alt="" style={{opacity: comp.name === "MAIN BP" ? 0.7 : 1}}/></div>
                                        <div style={{flex:1}}>
                                            <strong style={{color:'#eee', fontSize:'13px'}}>{cleanName}</strong>
                                        </div>
                                        <span className="count-badge">x{comp.itemCount}</span>
                                    </div>

                                    {/* SE È PRIME: MOSTRA LE RELIQUIE (Grid) */}
                                    {isPrime && (
                                        <div className="relic-cards-grid">
                                            {formatDropsWithVaultCheck(comp.drops).map((d, i) => {
                                                const isSelected = d.relicID && selectedRelics.has(d.relicID);
                                                return (
                                                    <div key={i} onClick={() => d.isRelic && handleRelicClick(d.relicID)}
                                                        className={`mini-relic-card ${isSelected ? 'selected' : ''} ${d.isVaultedRelic ? 'is-vaulted' : ''}`}
                                                    >
                                                        {d.imagePath && <img src={d.imagePath} className="relic-card-img" onError={(e)=>{e.target.style.display='none'}} />}
                                                        <div className="card-info">
                                                            <span className="card-name">{d.loc}</span>
                                                            <span className={`card-pct ${d.rarityClass}`}>{d.isVaultedRelic && <span className="vaulted-mini-tag">V</span>}</span>
                                                        </div>
                                                    </div>
                                                );
                                            })}
                                        </div>
                                    )}

                                    {/* SE È BASE: MOSTRA TABELLA MISSIONI DIRETTAMENTE QUI */}
                                    {!isPrime && (
                                        <div style={{marginTop:'5px', background:'#121215', border:'1px solid #333', borderRadius:'4px', overflow:'hidden'}}>
                                            {partMissions.length > 0 ? (
                                                <table className="mission-relics-table">
                                                    <tbody>
                                                        {partMissions.map((m, i) => (
                                                            <tr key={i}>
                                                                <td style={{color:'#fff', fontSize:'11px', padding:'6px 10px'}}>{m.loc}</td>
                                                                <td style={{textAlign:'center', color:'var(--gold)', fontSize:'11px', width:'50px'}}>{m.rot}</td>
                                                                <td style={{textAlign:'right', color:'#888', fontSize:'11px', width:'60px'}}>{(m.chance*100).toFixed(1)}%</td>
                                                            </tr>
                                                        ))}
                                                    </tbody>
                                                </table>
                                            ) : (
                                                <div style={{padding:'10px', fontSize:'11px', color:'#555', fontStyle:'italic', textAlign:'center'}}>
                                                    Check Market / Dojo / Quest
                                                </div>
                                            )}
                                        </div>
                                    )}
                                </div>
                            );
                        })}
                    </div>

                    {/* COLONNA 3: STRATEGIA (SOLO PER PRIME) */}
                    {isPrime && !isRelicItem && (
                        <div className="col-right">
                            <div style={{display:'flex', justifyContent:'space-between', alignItems:'baseline', marginBottom:'10px'}}>
                                <h3 className="section-title" style={{color:'var(--gold)', margin:0}}>
                                    {loadingStrategies ? statusMsg : (selectedRelics.size > 0 ? `FILTERED FARMING` : "OPTIMAL LOCATIONS")}
                                </h3>
                                {selectedRelics.size > 0 && <span style={{fontSize:'10px', color:'#666', cursor:'pointer'}} onClick={()=>setSelectedRelics(new Set())}>(CLEAR)</span>}
                            </div>
                            
                            <div className="strategy-container">
                                {smartMissions.length > 0 ? smartMissions.map((mission, idx) => (
                                    <div key={idx} className="mission-block">
                                        <div className="mission-block-header">
                                            <div className="mission-name-large">{mission.missionName}</div>
                                            {!selectedRelics.size && <div style={{fontSize:'10px', color:'#666', fontWeight:'bold'}}>{(mission.totalScore*100).toFixed(0)}% TOT</div>}
                                        </div>
                                        <table className="mission-relics-table">
                                            <thead>
                                                <tr>
                                                    <th style={{width:'30%'}}>RELIC</th>
                                                    <th style={{width:'20%', textAlign:'center'}}>PART</th>
                                                    <th style={{width:'20%', textAlign:'center'}}>ROT</th>
                                                    <th style={{width:'30%', textAlign:'right'}}>%</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                {mission.relicsFound.sort((a,b)=>b.maxChance - a.maxChance).map((r, i) => (
                                                    <tr key={i}>
                                                        <td style={{color:'#fff', fontWeight:'bold'}}>{r.id}</td>
                                                        <td style={{textAlign:'center'}}><span className="part-badge">{r.part}</span></td>
                                                        <td style={{textAlign:'center', color:'var(--gold)'}}>{(r.drops||[]).map(d=>d.rot).join('|')}</td>
                                                        <td style={{textAlign:'right', color:'#aaa'}}>{(r.drops||[]).map(d=>(d.chance*100).toFixed(0)).join('|')}%</td>
                                                    </tr>
                                                ))}
                                            </tbody>
                                        </table>
                                    </div>
                                )) : <div style={{textAlign:'center', padding:'40px', color:'#555', fontStyle:'italic'}}>No farming data available (Vaulted).</div>}
                            </div>
                        </div>
                    )}
                </div>
            </div>
        </div>
    );
}

==================================================
FILE: src\hooks\useItemStrategy.js
==================================================

// src/hooks/useItemStrategy.js
import { useState, useEffect, useMemo } from 'react';

// Utility pulizia nomi
const cleanRelicName = (fullName) => {
    return fullName.replace(" Relic", "").replace(/\s*\(.*?\)/g, "").trim();
};

export function useItemStrategy(item) {
    const [relicMap, setRelicMap] = useState(new Map());
    const [selectedRelics, setSelectedRelics] = useState(new Set());
    const [loadingRelics, setLoadingRelics] = useState(false);

    const isRelicItem = item?.category === 'Relics';

    // 1. Parsing Componenti
    const componentsList = useMemo(() => {
        if (isRelicItem || !item || !item.components) return [];
        
        const validParts = ['Blueprint', 'Chassis', 'Neuroptics', 'Systems', 'Harness', 'Wings', 'Engine', 'Cortex', 'Carapace', 'Cerebrum'];
        const filteredComponents = item.components.filter(comp => validParts.some(part => comp.name.includes(part)));
        
        // Ordinamento logico
        const order = ['Blueprint', 'Neuroptics', 'Chassis', 'Systems'];
        const sorted = [...filteredComponents].sort((a, b) => {
            const ia = order.findIndex(k => a.name.includes(k));
            const ib = order.findIndex(k => b.name.includes(k));
            return (ia === -1 ? 99 : ia) - (ib === -1 ? 99 : ib);
        });

        // Estrazione nomi reliquie necessarie
        return sorted.map(comp => {
            const rawRelics = (comp.drops || []).filter(d => d.location.includes(" Relic"));
            const uniqueRelics = new Map();
            
            rawRelics.forEach(d => {
                const baseName = cleanRelicName(d.location);
                if (!uniqueRelics.has(baseName)) {
                    uniqueRelics.set(baseName, { 
                        name: baseName, 
                        rarity: d.rarity || 'Common', 
                        chance: d.chance 
                    });
                }
            });

            return {
                name: comp.name.replace(item.name, "").replace("Blueprint", "BP").trim(),
                uniqueName: comp.uniqueName,
                relics: Array.from(uniqueRelics.values()).sort((a,b) => a.name.localeCompare(b.name))
            };
        });
    }, [item, isRelicItem]);

    // 2. Fetch Ottimizzato Reliquie (Solo quelle necessarie)
    useEffect(() => {
        if (!item) return;

        let relicsToFetch = [];
        if (isRelicItem) {
            relicsToFetch.push(cleanRelicName(item.name));
            setSelectedRelics(new Set([cleanRelicName(item.name)])); // Auto-select se è reliquia
        } else {
            // Raccogli tutti i nomi delle reliquie dai componenti
            componentsList.forEach(c => c.relics.forEach(r => relicsToFetch.push(r.name)));
        }

        // Rimuovi duplicati
        relicsToFetch = [...new Set(relicsToFetch)];

        if (relicsToFetch.length > 0) {
            setLoadingRelics(true);
            fetch('/api/relics/lookup', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ names: relicsToFetch })
            })
            .then(res => res.json())
            .then(data => {
                const map = new Map(data.map(r => [r.name, r]));
                setRelicMap(map);
            })
            .finally(() => setLoadingRelics(false));
        }
    }, [item, componentsList, isRelicItem]);

    // 3. Calcolo Strategia Farming
    const farmingStrategy = useMemo(() => {
        if (selectedRelics.size === 0) return null;
        const missions = [];
        const noDataRelics = [];

        selectedRelics.forEach(relicName => {
            const info = relicMap.get(relicName);
            // Se info manca ma siamo nella vista reliquia, usiamo i drop dell'item stesso
            const drops = info?.drops?.length > 0 ? info.drops : (isRelicItem ? item.drops : []);

            if (!drops || drops.length === 0) {
                noDataRelics.push(relicName);
            } else {
                drops.forEach(d => {
                    missions.push({
                        location: d.location,
                        relic: relicName,
                        chance: d.chance,
                        rotation: d.rotation
                    });
                });
            }
        });

        return {
            missions: missions.sort((a, b) => b.chance - a.chance).slice(0, 50),
            noData: noDataRelics
        };
    }, [selectedRelics, relicMap, item, isRelicItem]);

    const toggleRelic = (name) => {
        setSelectedRelics(prev => {
            const next = new Set(prev);
            if (next.has(name)) next.delete(name);
            else next.add(name);
            return next;
        });
    };

    return { 
        componentsList, 
        farmingStrategy, 
        selectedRelics, 
        toggleRelic,
        loadingRelics,
        isRelicItem
    };
}

==================================================
FILE: src\hooks\useOwnedItems.js
==================================================

// src/hooks/useOwnedItems.js
"use client";
import { useState, useEffect, useCallback } from 'react';

const STORAGE_KEY = 'warframe_codex_v7';

export function useOwnedItems() {
    const [ownedCards, setOwnedCards] = useState(new Set());
    const [isLoaded, setIsLoaded] = useState(false);

    // Carica dati all'avvio
    useEffect(() => {
        const saved = localStorage.getItem(STORAGE_KEY);
        if (saved) {
            try {
                setOwnedCards(new Set(JSON.parse(saved)));
            } catch (e) {
                console.error("Errore lettura salvataggio", e);
            }
        }
        setIsLoaded(true);
    }, []);

    // OTTIMIZZAZIONE PUNTO 4: Debounce del salvataggio
    useEffect(() => {
        if (!isLoaded) return;

        // Aspetta 1 secondo di inattività prima di scrivere su disco
        const handler = setTimeout(() => {
            localStorage.setItem(STORAGE_KEY, JSON.stringify([...ownedCards]));
        }, 1000);

        return () => clearTimeout(handler);
    }, [ownedCards, isLoaded]);

    const toggleOwned = useCallback((id) => {
        setOwnedCards(prev => {
            const newSet = new Set(prev);
            if (newSet.has(id)) newSet.delete(id);
            else newSet.add(id);
            return newSet;
        });
    }, []);

    const importItems = useCallback((itemsArray, rawData) => {
        setOwnedCards(prev => {
            const newSet = new Set(prev);
            let count = 0;
            itemsArray.forEach(entry => {
                const name = (typeof entry === 'string' ? entry : entry.item_name || entry.name).toLowerCase();
                const found = rawData.find(i => i.name.toLowerCase() === name);
                if (found) {
                    newSet.add(found.uniqueName);
                    count++;
                }
            });
            return newSet;
        });
    }, []);

    return { ownedCards, toggleOwned, importItems, isLoaded };
}

==================================================
FILE: src\utils\categoryConfig.js
==================================================

// src/utils/categoryConfig.js

const isArcane = (item) => item.category === 'Arcanes' || (item.type && item.type.toLowerCase().includes('arcane'));
const isGalvanized = (item) => item.name.includes('Galvanized ') || item.name.includes('Primed ') || item.name.includes('Amalgam ');
const isArchon = (item) => item.name.includes('Archon ');
const isWeaponType = (item) => {
    const t = (item.type || "").toLowerCase();
    return t.includes('primary') || t.includes('secondary') || t.includes('melee') || t.includes('gun');
};

export const CATEGORY_CONFIGS = {
    'warframes': [
        { id: 'all', label: 'WARFRAMES', filter: (item) => (item.type || "").toLowerCase() === 'warframe' }
    ],
    'companions': [
        {
            id: 'robotic', label: 'SENTINELS', 
            filter: (item) => {
                const t = (item.type || "").toLowerCase();
                return t.includes('sentinel') || t.includes('robotic') || t.includes('moa');
            }
        },
        {
            id: 'beast', label: 'BEASTS',
            filter: (item) => {
                const t = (item.type || "").toLowerCase();
                return t.includes('kubrow') || t.includes('kavat') || t.includes('beast');
            }
        },
        {
            id: 'necramech', label: 'NECRAMECHS',
            filter: (item) => (item.type || "").toLowerCase().includes('necramech')
        }
    ],
    'mods': [
        {
            id: 'base', label: 'BASE MODS',
            filter: (item) => {
                const isSpecial = isGalvanized(item) || isArchon(item) || item.name.includes('Riven') || isArcane(item);
                const isMod = item.category === 'Mods' || (item.type || "").toLowerCase().includes('aura');
                return !isSpecial && isMod;
            },
            subFilters: [
                { id: 'all', label: 'ALL', filter: () => true }, // Changed TUTTI -> ALL
                { id: 'wf', label: 'WARFRAME', filter: (item) => (item.type || "").toLowerCase().includes('warframe') },
                { id: 'wep', label: 'WEAPONS', filter: (item) => isWeaponType(item) }
            ]
        },
        {
            id: 'elite', label: 'PRIMED & GALVANIZED',
            filter: (item) => isGalvanized(item)
        },
        {
            id: 'arcanes', label: 'ARCANES',
            filter: (item) => isArcane(item)
        }
    ]
};

==================================================
FILE: src\utils\clientCategories.js
==================================================

// Questo file contiene le funzioni di filtro.
// Viene importato SOLO dai Client Components.

export const CATEGORY_CONFIGS = {
    'warframes': [
        {
            id: 'all', label: 'ALL',
            filter: (item) => (item.type || "").toLowerCase().includes('warframe') && 
                              item.category === 'Warframes' &&
                              !item.name.toLowerCase().includes('necramech')
        },
        {
            id: 'base', label: 'BASE',
            filter: (item) => (item.type || "").toLowerCase().includes('warframe') && 
                              item.category === 'Warframes' && 
                              !item.name.includes('Prime') &&
                              !item.name.toLowerCase().includes('necramech')
        },
        {
            id: 'prime', label: 'PRIME',
            filter: (item) => (item.type || "").toLowerCase().includes('warframe') && 
                              item.category === 'Warframes' && 
                              item.name.includes('Prime') &&
                              !item.name.toLowerCase().includes('necramech')
        }
    ],
    'primary': [
        { id: 'all', label: 'ALL', filter: (item) => item.category === 'Primary' },
        { id: 'base', label: 'BASE', filter: (item) => item.category === 'Primary' && !item.name.includes('Prime') && !item.name.includes('Vandal') && !item.name.includes('Wraith') },
        { id: 'prime', label: 'PRIME', filter: (item) => item.category === 'Primary' && item.name.includes('Prime') }
    ],
    'secondary': [
        { id: 'all', label: 'ALL', filter: (item) => item.category === 'Secondary' },
        { id: 'base', label: 'BASE', filter: (item) => item.category === 'Secondary' && !item.name.includes('Prime') && !item.name.includes('Vandal') && !item.name.includes('Wraith') },
        { id: 'prime', label: 'PRIME', filter: (item) => item.category === 'Secondary' && item.name.includes('Prime') }
    ],
    'melee': [
        { id: 'all', label: 'ALL', filter: (item) => item.category === 'Melee' },
        { id: 'base', label: 'BASE', filter: (item) => item.category === 'Melee' && !item.name.includes('Prime') && !item.name.includes('Vandal') && !item.name.includes('Wraith') },
        { id: 'prime', label: 'PRIME', filter: (item) => item.category === 'Melee' && item.name.includes('Prime') }
    ],
    'companions': [
        { id: 'all', label: 'ALL', filter: (item) => item.category === 'Sentinels' },
        { id: 'base', label: 'BASE', filter: (item) => item.category === 'Sentinels' && !item.name.includes('Prime') },
        { id: 'prime', label: 'PRIME', filter: (item) => item.category === 'Sentinels' && item.name.includes('Prime') }
    ],
    'relics': [
        {
            id: 'lith', label: 'LITH', filter: (i) => i.name.includes('Lith'),
            subFilters: [
                { id: 'all', label: 'INTACT', filter: (i) => i.name.includes('Intact') },
                { id: 'radiant', label: 'RADIANT', filter: (i) => i.name.includes('Radiant') },
                { id: 'everything', label: 'ALL', filter: () => true }
            ]
        },
        {
            id: 'meso', label: 'MESO', filter: (i) => i.name.includes('Meso'),
            subFilters: [
                { id: 'all', label: 'INTACT', filter: (i) => i.name.includes('Intact') },
                { id: 'radiant', label: 'RADIANT', filter: (i) => i.name.includes('Radiant') },
                { id: 'everything', label: 'ALL', filter: () => true }
            ]
        },
        {
            id: 'neo', label: 'NEO', filter: (i) => i.name.includes('Neo'),
            subFilters: [
                { id: 'all', label: 'INTACT', filter: (i) => i.name.includes('Intact') },
                { id: 'radiant', label: 'RADIANT', filter: (i) => i.name.includes('Radiant') },
                { id: 'everything', label: 'ALL', filter: () => true }
            ]
        },
        {
            id: 'axi', label: 'AXI', filter: (i) => i.name.includes('Axi'),
            subFilters: [
                { id: 'all', label: 'INTACT', filter: (i) => i.name.includes('Intact') },
                { id: 'radiant', label: 'RADIANT', filter: (i) => i.name.includes('Radiant') },
                { id: 'everything', label: 'ALL', filter: () => true }
            ]
        },
        {
            id: 'requiem', label: 'REQUIEM', filter: (i) => i.name.includes('Requiem'),
            subFilters: [
                { id: 'all', label: 'INTACT', filter: (i) => i.name.includes('Intact') },
                { id: 'radiant', label: 'RADIANT', filter: (i) => i.name.includes('Radiant') },
                { id: 'everything', label: 'ALL', filter: () => true }
            ]
        }
    ],
    'necramechs': [
         { id: 'all', label: 'NECRAMECHS', filter: (item) => (item.type || "").toLowerCase().includes('necramech') }
    ]
};

==================================================
FILE: src\utils\constants.js
==================================================

// Configurazione per GitHub Pages
const REPO_NAME = '/warframecodex-next'; 

// Verifica se siamo in produzione (GitHub) o sviluppo (Localhost)
const isProd = process.env.NODE_ENV === 'production';

// Se siamo in produzione, usiamo il nome del repo come prefisso per i dati
export const BASE_PATH = isProd ? REPO_NAME : '';

// 1. I dati JSON rimangono nel tuo repository (perché li hai personalizzati/scaricati)
export const API_BASE_URL = `${BASE_PATH}/database_api`;

// 2. LE IMMAGINI invece le prendiamo dalla CDN ufficiale (Niente scaricamento locale!)
export const IMG_BASE_URL = 'https://cdn.warframestat.us/img'; 

export const APP_VERSION = "6.8 - CDN Images";

==================================================
FILE: src\utils\relicUtils.js
==================================================

// src/utils/relicUtils.js
import { fetchGameData } from '@/utils/serverData';

// Mappa globale per la sessione client
let relicCache = null;

export async function getRelicDatabase() {
    if (relicCache) return relicCache;

    try {
        // Scarica il file Relics.json (che ora è locale grazie a serverData)
        // Nota: In Next.js App Router, per i client component, usiamo una API route interna
        // Ma per semplificare, possiamo fare una chiamata fetch al file statico o usare l'API che creeremo
        const res = await fetch('/database_api/Relics.json'); // Legge dalla cartella public o via API
        
        // Se non funziona (es. siamo lato server), usiamo un fallback o l'API
        let data;
        if (!res.ok) {
             // Fallback: prova a chiamare l'API di sync se il file non è accessibile direttamente
             const apiRes = await fetch('/api/sync-db'); 
             // Questo è un workaround, l'ideale è che il client riceva i dati puliti
             data = await apiRes.json(); // Questo tornerebbe tutto, è pesante.
             // Meglio: Il client component riceve i dati delle reliquie via props o fetch ottimizzata.
             // Per ora assumiamo che il file sia accessibile o usiamo un metodo diretto.
             return new Map(); 
        } else {
             data = await res.json();
        }

        const map = new Map();
        
        data.forEach(item => {
            // FILTRO RIGIDO: Solo Reliquie, NO Radiant/Flawless/Exceptional
            if (item.category === 'Relics' && 
                !item.name.includes('(Radiant)') && 
                !item.name.includes('(Flawless)') && 
                !item.name.includes('(Exceptional)')) {
                
                // Pulizia Nome: "Lith G1 Relic (Intact)" -> "Lith G1"
                const cleanName = item.name
                    .replace(" Relic", "")
                    .replace(" (Intact)", "")
                    .trim();
                
                map.set(cleanName, {
                    id: item.uniqueName,
                    name: cleanName,
                    image: item.imageName,
                    drops: item.drops || [], // Dove si trova questa reliquia
                    vaulted: !item.drops || item.drops.length === 0
                });
            }
        });

        relicCache = map;
        return map;
    } catch (e) {
        console.error("Relic DB Error", e);
        return new Map();
    }
}

==================================================
FILE: src\utils\serverData.js
==================================================

import fs from 'fs/promises';
import path from 'path';
import { API_BASE_URL } from './constants';

// Determina la cartella del database in modo sicuro
// process.cwd() è la root del progetto durante la build
const DB_FOLDER = path.join(process.cwd(), 'public', 'database_api'); 
// NOTA: Ho aggiunto 'public'. Se la tua cartella 'database_api' è nella root (fuori da public), togli 'public'.
// Ma per Next.js, i file statici accessibili via fetch dovrebbero stare in /public/database_api.
// SE LA CARTELLA è nella root del progetto (allo stesso livello di src), usa:
// const DB_FOLDER = path.join(process.cwd(), 'database_api');

// Cache globale per evitare riletture durante la build
global.dataCache = global.dataCache || {};

export async function fetchGameData(filename) {
    // 1. Controlla Cache RAM
    if (global.dataCache[filename]) {
        return global.dataCache[filename];
    }

    // 2. Tenta lettura da File System (Obbligatorio per la Build)
    // Cerchiamo sia in root/database_api che in root/public/database_api per sicurezza
    const possiblePaths = [
        path.join(process.cwd(), 'database_api', filename),
        path.join(process.cwd(), 'public', 'database_api', filename)
    ];

    for (const filePath of possiblePaths) {
        try {
            const fileContent = await fs.readFile(filePath, 'utf-8');
            const json = JSON.parse(fileContent);
            global.dataCache[filename] = json;
            return json;
        } catch (e) {
            // Continua al prossimo path
        }
    }

    // 3. Se fallisce FS, evita fetch durante la build statica
    // Restituisci array vuoto per non rompere la build
    console.warn(`[SERVER WARNING] Could not load ${filename} from FS. Returning empty array.`);
    return [];
}