DATA DUMP: 2025-12-23T10:23:29.235Z



==================================================
FILE: src\app\companions\page.js
==================================================

"use client";
import CodexListPage from '@/components/CodexListPage';

// Configurazione Categorie
const COMPANION_CATS = [
    { 
        id: 'all', 
        label: 'ALL COMPANIONS', 
        filter: () => true,
        subFilters: [
             { id: 'sentinel', label: 'SENTINELS', filter: i => i.category === 'Sentinels' },
             { id: 'pet', label: 'BEASTS', filter: i => i.category === 'Pets' }, // Kubrow/Kavat
             { id: 'robotic', label: 'HOUNDS/MOA', filter: i => i.type && (i.type.includes('Hound') || i.type.includes('MOA')) }
        ]
    },
    { id: 'sentinels', label: 'SENTINELS ONLY', filter: i => i.category === 'Sentinels' },
    { id: 'pets', label: 'BEASTS ONLY', filter: i => i.category === 'Pets' },
];

export default function Page() {
    return (
        <CodexListPage 
            filesToLoad={['Sentinels.json', 'Pets.json']} 
            pageTitle="COMPANIONS" 
            customCategories={COMPANION_CATS}
        />
    );
}

==================================================
FILE: src\app\error.js
==================================================

// src/app/error.js
"use client";

export default function Error({ error, reset }) {
  return (
    <div style={{padding: '50px', color: 'white', textAlign: 'center'}}>
      <h2 style={{color: '#ff6b6b'}}>SYSTEM FAILURE</h2>
      <p>Ordis has encountered an error:</p>
      <pre style={{background: '#222', padding: '20px', borderRadius: '5px', display:'inline-block', textAlign:'left'}}>
        {error.message}
      </pre>
      <br />
      <button 
        onClick={() => reset()} 
        style={{marginTop: '20px', padding: '10px 20px', background: '#d4af37', border: 'none', cursor: 'pointer', fontWeight:'bold'}}
      >
        REBOOT SYSTEM
      </button>
    </div>
  );
}

==================================================
FILE: src\app\globals.css
==================================================

@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --bg-deep: #050505;
  --bg-card: #121214;
  --bg-header: rgba(10, 10, 12, 0.90);
  --border-color: #27272a;
  --text-main: #ededed;
  --text-muted: #888888;
  --gold: #d4af37;
  --gold-dim: #8a7224;
  --gold-glow: rgba(212, 175, 55, 0.4);
  --blue-energy: #3b82f6;
  --blue-glow: rgba(59, 130, 246, 0.4);
  --green-tech: #5fffa5;
  --red-vault: #ff5555;
  --font-roboto: "Roboto Condensed", sans-serif;
}

/* 1. RESET */
* { box-sizing: border-box; padding: 0; margin: 0; }
html, body {
  height: 100%; width: 100%; background-color: var(--bg-deep); 
  color: var(--text-main); font-family: var(--font-roboto); overflow: hidden;
}

/* =========================================
   2. HOMEPAGE (LANDING)
   ========================================= */
.landing-page {
  height: 100vh; width: 100vw;
  background: radial-gradient(circle at center, #1a1a20 0%, #050505 90%);
  position: relative; display: flex; flex-direction: column; overflow: hidden;
}
.landing-page::before {
  content: ""; position: absolute; inset: 0;
  background-image: 
    linear-gradient(rgba(255, 255, 255, 0.03) 1px, transparent 1px),
    linear-gradient(90deg, rgba(255, 255, 255, 0.03) 1px, transparent 1px);
  background-size: 50px 50px;
  mask-image: radial-gradient(circle at center, black 40%, transparent 80%);
  pointer-events: none; z-index: 0;
}
.landing-content {
  position: relative; z-index: 2; height: 100%; width: 100%;
  display: flex; flex-direction: column; justify-content: center; align-items: center;
}
.landing-title {
  font-size: 70px; font-weight: 900; letter-spacing: 15px; color: #fff;
  text-transform: uppercase; margin: 0;
  text-shadow: 0 0 30px rgba(255, 255, 255, 0.1);
  background: linear-gradient(to bottom, #fff, #999);
  -webkit-background-clip: text; -webkit-text-fill-color: transparent;
}
.landing-subtitle {
  font-size: 13px; color: var(--gold); letter-spacing: 6px; text-transform: uppercase;
  margin-top: 15px; font-weight: bold; text-shadow: 0 0 10px var(--gold-glow);
}
.cards-scroll-container {
  width: 100%; padding: 20px 0; display: flex; justify-content: center;
  overflow-x: auto; scrollbar-width: none;
}
.cards-row { display: flex; gap: 25px; padding: 0 50px; align-items: center; }

.menu-card {
  flex: 0 0 auto; width: 240px; height: 340px;
  background: rgba(18, 18, 20, 0.6); border: 1px solid #333; border-radius: 8px;
  position: relative; overflow: hidden; display: flex; flex-direction: column; justify-content: flex-end;
  transition: all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1); backdrop-filter: blur(5px); text-decoration: none;
}
.menu-card:hover { transform: translateY(-15px) scale(1.05); border-color: var(--gold); box-shadow: 0 0 30px var(--gold-glow); z-index: 10; }
.card-visual-area { position: absolute; inset: 0; z-index: 0; transition: 0.5s; filter: grayscale(100%) brightness(0.5); }
.menu-card:hover .card-visual-area { filter: grayscale(0%) brightness(1); transform: scale(1.1); }
.card-img-element { width: 100%; height: 100%; object-fit: cover; }
.card-content { position: relative; z-index: 2; padding: 25px; background: linear-gradient(to top, #000 10%, transparent); width: 100%; text-align: center; border-top: 1px solid rgba(255,255,255,0.05); }
.card-title { font-size: 20px; font-weight: 900; text-transform: uppercase; color: #fff; letter-spacing: 1px; }

/* =========================================
   3. PAGINE INTERNE (MAIN HEADER & CODEX)
   ========================================= */
.codex-layout { display: flex; flex-direction: column; height: 100vh; width: 100vw; overflow: hidden; background: radial-gradient(circle at top center, #15151a 0%, #000000 100%); }

/* HEADER PRINCIPALE (Il ripristino che chiedevi) */
.header-group {
  flex-shrink: 0; background: var(--bg-header); backdrop-filter: blur(12px);
  z-index: 50; border-bottom: 1px solid rgba(255,255,255,0.05);
  box-shadow: 0 10px 30px rgba(0,0,0,0.5); display: flex; flex-direction: column;
}

.nav-top-row {
  display: flex; align-items: center; justify-content: space-between;
  padding: 0 40px; height: 70px;
}
.nav-brand { display: flex; align-items: center; gap: 20px; }
.nav-home-btn {
  font-size: 11px; font-weight: bold; letter-spacing: 2px; color: var(--text-muted);
  text-decoration: none; text-transform: uppercase; padding: 8px 12px;
  border: 1px solid #333; border-radius: 4px; transition: all 0.3s;
}
.nav-home-btn:hover { border-color: var(--gold); color: var(--gold); box-shadow: 0 0 10px var(--gold-glow); }

.page-title {
  font-size: 28px; font-weight: 900; color: #fff; text-transform: uppercase; letter-spacing: 2px;
  text-shadow: 0 0 20px rgba(255,255,255,0.1);
  border-left: 3px solid var(--gold); padding-left: 20px; line-height: 1;
}

/* Stats */
.stats-right { display: flex; align-items: center; gap: 30px; }
.stat-box { text-align: right; }
.stat-label { font-size: 9px; color: #666; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 2px; }
.stat-value { font-size: 18px; color: #fff; font-weight: 300; font-family: monospace; }
.stat-value span { color: var(--gold); font-weight: bold; }

/* Controlli e Filtri */
.controls-row {
  display: flex; align-items: center; justify-content: space-between;
  padding: 15px 40px; background: rgba(0,0,0,0.3);
  border-top: 1px solid rgba(255,255,255,0.03);
}

.filters-left { display: flex; gap: 20px; align-items: center; }
.category-tabs { display: flex; gap: 5px; }
.tab-btn {
  background: transparent; border: none; border-bottom: 2px solid transparent;
  color: #666; font-size: 12px; font-weight: bold; text-transform: uppercase; letter-spacing: 1px;
  padding: 8px 12px; cursor: pointer; transition: all 0.3s;
}
.tab-btn:hover { color: #fff; background: rgba(255,255,255,0.05); }
.tab-btn.active { 
  color: var(--gold); border-bottom-color: var(--gold); 
  background: linear-gradient(to top, rgba(212, 175, 55, 0.1), transparent);
}

.sub-filters-container { display: flex; gap: 8px; border-left: 1px solid #444; padding-left: 20px; }
.pill-btn {
  font-size: 10px; text-transform: uppercase; font-weight: bold; padding: 5px 12px;
  background: #1a1a1e; color: #888; border: 1px solid #333; border-radius: 20px; cursor: pointer;
  transition: all 0.2s;
}
.pill-btn:hover { border-color: #777; color: #fff; }
.pill-btn.active { background: var(--gold); color: #000; border-color: var(--gold); box-shadow: 0 0 10px var(--gold-glow); }

.search-wrapper { position: relative; }
.search-input { 
  background: #08080a; border: 1px solid #333; color: #fff; 
  padding: 8px 15px; width: 220px; border-radius: 4px; font-size: 12px; 
  text-transform: uppercase; letter-spacing: 1px; transition: 0.3s;
}
.search-input:focus { outline: none; border-color: var(--gold); box-shadow: 0 0 15px var(--gold-glow); background: #000; }

.toggle-missing {
  display: flex; align-items: center; gap: 8px; cursor: pointer; color: #888; 
  font-size: 11px; font-weight: bold; text-transform: uppercase; letter-spacing: 1px; transition: 0.3s;
}
.toggle-missing:hover { color: #fff; }
.checkbox-custom {
  width: 14px; height: 14px; border: 1px solid #555; background: #000;
  display: flex; align-items: center; justify-content: center; font-size: 10px; color: var(--gold);
}
.toggle-missing input:checked + .checkbox-custom { border-color: var(--gold); box-shadow: 0 0 5px var(--gold-glow); }

.btn-import {
  background: rgba(59, 130, 246, 0.1); border: 1px solid rgba(59, 130, 246, 0.4); color: var(--blue-energy);
  padding: 6px 14px; font-size: 10px; font-weight: bold; text-transform: uppercase; letter-spacing: 1px;
  cursor: pointer; transition: 0.3s; display: flex; align-items: center; gap: 6px; border-radius: 4px;
}
.btn-import:hover { background: var(--blue-energy); color: #fff; box-shadow: 0 0 15px var(--blue-glow); }

/* Gallery Scroll Area */
.gallery-scroll-area {
  flex-grow: 1; overflow-y: auto; padding: 40px;
  scrollbar-width: thin; scrollbar-color: #333 transparent;
}
.gallery-scroll-area::-webkit-scrollbar { width: 6px; }
.gallery-scroll-area::-webkit-scrollbar-thumb { background: #444; border-radius: 3px; }

.card-gallery {
  display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); 
  gap: 25px; padding-bottom: 100px;
}

/* Card Principale (Griglia) */
.card-wrapper {
  background: var(--bg-card); border: 1px solid var(--border-color); border-radius: 6px;
  overflow: hidden; display: flex; flex-direction: column; position: relative;
  transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
  box-shadow: 0 4px 6px rgba(0,0,0,0.3); height: 400px;
}
.card-wrapper:hover { transform: translateY(-5px); box-shadow: 0 15px 40px rgba(0,0,0,0.6); border-color: #555; }
.card-wrapper[data-rarity="Prime"] { border-top: 2px solid var(--gold); }
.card-wrapper[data-rarity="Prime"]:hover { border-color: var(--gold); box-shadow: 0 10px 30px rgba(212, 175, 55, 0.2); }

.owned-check { 
  position: absolute; top: 10px; left: 10px; width: 24px; height: 24px;
  background: rgba(0,0,0,0.6); border: 1px solid rgba(255,255,255,0.2);
  display: flex; align-items: center; justify-content: center; 
  color: #fff; z-index: 10; border-radius: 4px; cursor: pointer; transition: 0.2s;
}
.owned-check:hover { background: rgba(255,255,255,0.2); }
.card-wrapper.owned .owned-check { background: var(--blue-energy); border-color: var(--blue-energy); box-shadow: 0 0 10px var(--blue-glow); }
.card-wrapper.owned .card-image-img { filter: grayscale(100%) brightness(0.6); }

.card-image-container { 
  height: 180px; width: 100%; display: flex; align-items: center; justify-content: center;
  background: radial-gradient(circle at center, #1f1f25 0%, #121214 100%);
  padding: 15px; position: relative; border-bottom: 1px solid #1a1a1e;
}
.card-image-img { 
  max-width: 100%; max-height: 100%; object-fit: contain; 
  filter: drop-shadow(0 5px 15px rgba(0,0,0,0.6)); transition: 0.3s;
}
.card-wrapper:hover .card-image-img { transform: scale(1.05); }

.info-area { 
  padding: 15px; flex-grow: 1; display: flex; flex-direction: column; 
  align-items: center; text-align: center; background: #151518;
}

.mod-name { font-size: 15px; font-weight: 800; text-transform: uppercase; color: #fff; margin-bottom: 4px; letter-spacing: 0.5px; }
.type-pill { font-size: 9px; color: #555; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px; font-weight: bold; }
.card-desc { font-size: 11px; color: #888; line-height: 1.4; margin-bottom: auto; display: -webkit-box; -webkit-line-clamp: 4; -webkit-box-orient: vertical; overflow: hidden; width: 100%; }

.hidden-file-input { display: none; }

/* =========================================
   4. MODALE DETTAGLIO (FULL SCREEN & STILE NUOVO)
   ========================================= */

.modal-overlay { 
  position: fixed; inset: 0; background: rgba(0,0,0,0.95); backdrop-filter: blur(10px); 
  z-index: 1000; display: flex; align-items: center; justify-content: center; 
}

.modal-content-simple { 
  width: 95vw; height: 90vh; max-width: 1600px;
  background: #08080a; border: 1px solid #333; border-radius: 4px; 
  overflow: hidden; position: relative; box-shadow: 0 0 100px rgba(0,0,0,0.9); 
  display: flex; flex-direction: column;
}

.close-btn { 
  position: absolute; top: 20px; right: 25px; 
  color: #fff; font-size: 28px; background: none; border: none; 
  cursor: pointer; z-index: 20; opacity: 0.6; transition: 0.2s;
}
.close-btn:hover { opacity: 1; color: var(--gold); }

/* HEADER MODALE */
.modal-header-row {
  display: flex; justify-content: space-between; align-items: center;
  /* PADDING DESTRO AGGIUNTO PER EVITARE LA X */
  padding: 25px 70px 25px 35px; 
  border-bottom: 1px solid #222; background: #0a0a0c;
}
.modal-title { font-size: 36px; font-weight: 900; color: #fff; text-transform: uppercase; letter-spacing: 1px; }

/* BODY (3 Colonne Flex) */
.modal-body { flex: 1; display: flex; overflow: hidden; padding: 0; }

.col-left {
  width: 320px; flex-shrink: 0; padding: 30px;
  border-right: 1px solid #222; background: #050505;
  display: flex; flex-direction: column; align-items: center; overflow-y: auto;
}

.col-center {
  flex: 1; padding: 30px;
  border-right: 1px solid #222; background: #0b0b0e;
  overflow-y: auto;
}

.col-right {
  flex: 1.4; padding: 30px;
  background: #08080a; overflow-y: auto;
}

/* UI MODALE */
.section-title { 
  color: var(--gold-dim); border-bottom: 1px solid #222; padding-bottom: 10px; margin-bottom: 20px; 
  font-size: 13px; text-transform: uppercase; letter-spacing: 2px; font-weight: bold; 
}
.btn-toggle-large {
  width: 100%; padding: 15px; margin-top: 25px;
  background: var(--gold); color: #000; font-weight: 800; letter-spacing: 1px;
  border: none; border-radius: 2px; cursor: pointer; text-transform: uppercase;
}
.btn-toggle-large.owned { background: #222; color: #fff; border: 1px solid #444; }
.wiki-btn-block {
  display: block; width: 100%; text-align: center; margin-top: 15px; padding: 10px;
  background: transparent; color: #666; border: 1px solid #222; font-size: 11px;
  letter-spacing: 1px; text-transform: uppercase; transition: 0.2s;
}
.wiki-btn-block:hover { color: #fff; border-color: #555; background: #111; }
.vault-badge { font-size: 11px; padding: 6px 16px; border-radius: 2px; font-weight: bold; letter-spacing: 1px; }
.vault-badge.is-vaulted { background: rgba(255, 50, 50, 0.1); color: #ff5555; border: 1px solid rgba(255, 50, 50, 0.3); }
.vault-badge.is-available { background: rgba(50, 255, 100, 0.05); color: #5fffa5; border: 1px solid rgba(50, 255, 100, 0.2); }
.warframe-description { font-size: 13px; color: #999; font-style: italic; line-height: 1.5; text-align: center; margin-bottom: 20px; padding: 0 10px; }

/* --- COMPONENTI MODALE --- */
.component-row { margin-bottom: 30px; }
.component-header { 
  display: flex; align-items: center; margin-bottom: 12px; 
  background: #121215; padding: 10px; border-radius: 4px; border: 1px solid #222;
}
.component-icon { width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; margin-right: 15px; }
.component-icon img { max-width: 100%; max-height: 100%; }
.count-badge { font-size: 10px; background: #000; color: #666; padding: 3px 8px; border-radius: 4px; border: 1px solid #222; margin-left: auto; }

/* MINI CARTE RELIQUIE */
.relic-cards-grid {
  display: grid; grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
  gap: 10px;
}

.mini-relic-card {
  background: #1a1a1d;
  border: 1px solid #333; border-radius: 4px; padding: 10px;
  display: flex; flex-direction: row; align-items: center; gap: 12px;
  position: relative; min-height: 55px; transition: all 0.2s;
  cursor: pointer; overflow: hidden;
}
.mini-relic-card:hover {
  border-color: #666; background: #222;
  box-shadow: 0 4px 15px rgba(0,0,0,0.5); transform: translateY(-2px);
}

/* STILE CARTA VAULTED */
.mini-relic-card.is-vaulted {
  opacity: 0.6; border-color: #3a2a2a; background: #141010;
}
.mini-relic-card.is-vaulted:hover { opacity: 1; border-color: var(--red-vault); }

/* STILE CARTA SELEZIONATA (Multi-Selezione) */
.mini-relic-card.selected {
  border-color: var(--gold);
  background: rgba(212, 175, 55, 0.08); /* Sfondo dorato tenue */
  box-shadow: 0 0 10px rgba(212, 175, 55, 0.3);
  opacity: 1 !important;
}
.mini-relic-card.selected .card-name { color: var(--gold); }
.mini-relic-card.selected .relic-icon-svg { fill: var(--gold); filter: drop-shadow(0 0 5px var(--gold-glow)); }

.mini-relic-card.is-mission { border-style: solid; background: #0f0f11; cursor: default; }

/* Immagini e Icone */
.relic-card-img {
  width: 32px; height: 32px; object-fit: contain;
  filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5)); flex-shrink: 0;
}
.mission-icon-svg { width: 24px; height: 24px; fill: #444; flex-shrink: 0; }

/* Icona SVG della Reliquia (Esagono) */
.relic-icon-svg { 
  width: 28px; height: 28px; 
  fill: #444; filter: drop-shadow(0 0 2px rgba(0,0,0,0.5));
  transition: 0.3s; flex-shrink: 0;
}
.mini-relic-card:hover .relic-icon-svg { fill: #888; } 

.card-info { display: flex; flex-direction: column; flex: 1; min-width: 0; justify-content: center; }
.card-name { font-size: 12px; color: #fff; font-weight: 700; line-height: 1.1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.card-pct { display: flex; align-items: center; font-size: 11px; color: var(--gold); font-weight: 600; margin-top: 3px; }

/* TAG VAULTED MINI */
.vaulted-mini-tag {
  font-size: 8px; color: var(--red-vault); background: rgba(255, 85, 85, 0.1);
  padding: 1px 4px; border-radius: 2px; margin-left: 6px; border: 1px solid rgba(255, 85, 85, 0.3);
  font-weight: 900; letter-spacing: 0.5px;
}

/* --- STRATEGIA --- */
.strategy-container { display: flex; flex-direction: column; gap: 15px; }
.mission-block {
  background: #121215; border: 1px solid #2a2a2e; border-radius: 4px;
  padding: 0; overflow: hidden;
}
.mission-block-header { 
  background: #18181b; padding: 10px 15px; border-bottom: 1px solid #222;
  display: flex; justify-content: space-between; align-items: center;
}
.mission-name-large { font-size: 13px; font-weight: bold; color: #fff; letter-spacing: 0.5px; }
.mission-relics-table { width: 100%; border-collapse: collapse; }
.mission-relics-table th { text-align: left; font-size: 9px; color: #555; padding: 8px 15px; background: #0e0e10; font-weight: bold; letter-spacing: 1px; }
.mission-relics-table td { padding: 10px 15px; border-bottom: 1px solid #1f1f22; font-size: 12px; vertical-align: middle; color: #bbb; }
.mission-relics-table tr:last-child td { border: none; }

.part-badge {
  display: inline-block; background: rgba(95, 255, 165, 0.08); border: 1px solid rgba(95, 255, 165, 0.2);
  color: var(--green-tech); padding: 2px 8px; border-radius: 3px;
  font-size: 9px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.5px;
}

/* Scrollbars */
div::-webkit-scrollbar { width: 6px; }
div::-webkit-scrollbar-track { background: #050505; }
div::-webkit-scrollbar-thumb { background: #333; border-radius: 3px; }
div::-webkit-scrollbar-thumb:hover { background: #555; }

==================================================
FILE: src\app\layout.js
==================================================

import { Roboto_Condensed } from "next/font/google";
import './globals.css'; // Carica solo le basi per tutta l'app

const robotoCondensed = Roboto_Condensed({ 
  subsets: ["latin"], 
  weight: ["300", "400", "700"],
  variable: "--font-roboto",
});

export const metadata = {
  title: "Ordis Codex",
  description: "Warframe Tracker",
};

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body className={robotoCondensed.className}>
        {children}
      </body>
    </html>
  );
}

==================================================
FILE: src\app\melee\page.js
==================================================

import CodexListPage from '@/components/CodexListPage';
import { fetchGameData } from '@/utils/serverData';

export default async function Page() {
    const data = await fetchGameData('Melee.json');
    return <CodexListPage initialData={data} pageTitle="MELEE WEAPONS" />;
}

==================================================
FILE: src\app\modal.css
==================================================

/* =========================================
   STILE FINESTRA MODALE (WARFRAME DETAIL)
   ========================================= */

.modal-overlay {
  position: fixed; top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0, 0, 0, 0.9);
  backdrop-filter: blur(8px);
  z-index: 1000;
  display: flex; align-items: center; justify-content: center;
  padding: 20px;
}

.modal-content.three-columns {
  width: 95vw;
  height: 90vh;
  max-width: 1600px;
  display: flex;
  flex-direction: row; /* Layout Orizzontale a 3 Colonne */
  background: #141418;
  border: 1px solid #444;
  border-top: 3px solid var(--gold);
  overflow: hidden;
  position: relative;
  box-shadow: 0 0 50px rgba(0,0,0,1);
}

.close-btn {
  position: absolute; top: 5px; right: 10px; background: none;
  border: none; color: #fff; font-size: 30px; cursor: pointer; z-index: 20;
}
.close-btn:hover { color: var(--gold); }

/* --- COLONNE COMUNI --- */
.column-info, .column-relics, .column-strategy {
  display: flex; flex-direction: column; height: 100%;
  border-right: 2px solid #2a2a2e;
  overflow: hidden;
}

/* --- COLONNA 1: INFO (25%) --- */
.column-info { flex: 0 0 25%; min-width: 300px; background: #101012; padding: 20px; }

.det-title { font-size: 24px; color: #fff; margin: 0; text-transform: uppercase; }
.det-subtitle { color: var(--gold); font-size: 12px; margin-bottom: 20px; }
.det-img-box { flex-grow: 1; display: flex; align-items: center; justify-content: center; }
.det-img-box img { max-width: 100%; max-height: 250px; filter: drop-shadow(0 0 10px #000); }
.det-desc { font-size: 12px; color: #888; overflow-y: auto; max-height: 150px; margin-bottom: 20px; line-height: 1.5; }

/* Mini lista posseduti */
.mini-owned-list { background: #1a1a1e; padding: 10px; border-radius: 4px; border: 1px solid #333; }
.mini-own-item { font-size: 11px; color: #888; margin-bottom: 4px; border-bottom: 1px solid #222; padding-bottom: 2px; }
.mini-own-item.ok { color: #2ecc71; font-weight: bold; }
.mini-own-item b { float: right; }

/* --- COLONNA 2: RELIQUIE (35%) --- */
.column-relics { flex: 0 0 35%; background: #0e0e10; }

.col-header {
  padding: 15px; background: #000; border-bottom: 1px solid #333;
  font-size: 14px; font-weight: bold; color: #fff; letter-spacing: 1px;
  text-transform: uppercase; text-align: center; border-left: 4px solid var(--gold);
}

.col-scrollable { padding: 15px; overflow-y: auto; flex-grow: 1; }
.tier-grid { display: flex; flex-wrap: wrap; gap: 8px; align-content: flex-start; }

.relic-sub-group { margin-bottom: 25px; border-bottom: 1px dashed #333; padding-bottom: 15px; }
.relic-sub-group:last-child { border-bottom: none; }

.relic-sub-group-title {
  font-size: 11px; font-weight: 800; color: #fff; background: #222;
  padding: 5px 10px; border-left: 3px solid var(--blue-energy); margin-bottom: 10px;
  text-transform: uppercase; letter-spacing: 1px;
}

/* Card Reliquia */
.relic-card-item {
  width: 90px; height: 100px;
  background: #1a1a1e; border: 1px solid #333; border-radius: 4px;
  display: flex; flex-direction: column; align-items: center; justify-content: center;
  position: relative; cursor: pointer; transition: transform 0.1s;
  flex-shrink: 0;
}
.relic-card-item:hover { transform: translateY(-2px); background: #222; }
.relic-card-item.active { border-color: var(--gold); box-shadow: 0 0 8px rgba(212,175,55,0.3); z-index: 5; }
.relic-card-item.vaulted { border-top: 3px solid #e55; }
.relic-card-item.available { border-top: 3px solid #2ecc71; }

.r-icon-area img { width: 40px; height: 40px; object-fit: contain; margin-bottom: 5px; }
.r-name { font-size: 10px; font-weight: bold; color: #fff; text-align: center; }
.r-status { font-size: 7px; opacity: 0.8; margin-bottom: 4px; }
.r-check {
  position: absolute; top: 2px; right: 2px; background: var(--gold); color: #000;
  width: 14px; height: 14px; font-size: 9px; display: flex; align-items: center;
  justify-content: center; border-radius: 50%;
}

/* Badge e Rarità */
.rarity-bar { position: absolute; bottom: 0; left: 0; width: 100%; height: 4px; }
.bar-bronze { background: #cd7f32; box-shadow: 0 0 5px #cd7f32; }
.bar-silver { background: #c0c0c0; box-shadow: 0 0 5px #c0c0c0; }
.bar-gold   { background: #d4af37; box-shadow: 0 0 8px #d4af37; }

.relic-chance-badge {
  position: absolute; top: 4px; right: 4px; left: auto; color: #000;
  font-size: 8px; font-weight: 800; padding: 1px 4px; border-radius: 2px;
  z-index: 10; box-shadow: 0 2px 4px rgba(0,0,0,0.8);
}

/* --- COLONNA 3: STRATEGIA (40% - Restante) --- */
.column-strategy { flex: 1; background: #111; border-right: none; }

.strategy-list { display: flex; flex-direction: column; gap: 10px; }

.mission-card { background: #1a1a1e; border: 1px solid #333; border-radius: 4px; overflow: hidden; }

.mc-header {
  background: #222; padding: 8px 10px; border-bottom: 1px solid #333;
  display: flex; justify-content: space-between; align-items: center;
}

.mc-loc { color: #fff; font-weight: bold; font-size: 13px; }
.mc-rot-badge { color: var(--gold); font-weight: 800; margin-left: 5px; text-transform: uppercase; }
.mc-type { color: #aaa; font-size: 11px; text-transform: uppercase; font-weight: bold; }

/* Lista Testo Strategia */
.mc-relics-list { padding: 8px 12px; }

.mc-text-row {
  font-size: 12px; margin-bottom: 4px; border-bottom: 1px solid #252525;
  padding-bottom: 2px; color: #ccc; display: flex; align-items: center;
}
.mc-text-row:last-child { border-bottom: none; }

.mt-comp { color: #888; font-weight: bold; margin-right: 5px; min-width: 70px; }
.mt-relic { color: #fff; font-weight: bold; }
.mt-rot { color: var(--gold); font-weight: bold; margin-left: 5px; }
.mt-chance { color: var(--blue-energy); margin-left: auto; font-weight: bold; }

/* Stati vuoti */
.empty-state-placeholder, .col-loading, .col-empty, .strategy-placeholder, .strategy-empty {
  padding: 30px; text-align: center; color: #666; font-size: 12px;
  display: flex; align-items: center; justify-content: center; height: 100%; font-style: italic;
}
/* src/app/modal.css */

/* MODALE GENERALE */
.modal-overlay {
  position: fixed; inset: 0; background: rgba(0, 0, 0, 0.9);
  backdrop-filter: blur(10px); z-index: 1000;
  display: flex; align-items: center; justify-content: center;
}

.modal-content.three-columns {
  width: 95vw; height: 90vh; max-width: 1600px;
  display: flex; background: #121214;
  border: 1px solid #333; border-top: 3px solid var(--gold);
  position: relative; box-shadow: 0 0 50px #000;
}

.close-btn {
  position: absolute; top: 15px; right: 20px; font-size: 28px;
  color: #fff; background: none; border: none; cursor: pointer; z-index: 50;
}
.close-btn:hover { color: var(--gold); }

/* LAYOUT COLONNE */
.column-info { flex: 0 0 25%; background: #0a0a0c; padding: 30px; border-right: 1px solid #333; display: flex; flex-direction: column; }
.column-components { flex: 0 0 40%; background: #121214; padding: 0; border-right: 1px solid #333; display: flex; flex-direction: column; overflow: hidden; }
.column-strategy { flex: 1; background: #0e0e10; padding: 0; display: flex; flex-direction: column; overflow: hidden; }

/* COL 1: INFO */
.det-title { font-size: 36px; font-weight: 900; color: #fff; margin: 0; text-transform: uppercase; line-height: 1; }
.det-subtitle { color: var(--gold); font-size: 14px; font-weight: bold; margin-bottom: 30px; text-transform: uppercase; letter-spacing: 1px; }
.det-img-box { flex: 1; display: flex; align-items: center; justify-content: center; margin-bottom: 20px; }
.det-img-box img { width: 100%; max-height: 400px; object-fit: contain; filter: drop-shadow(0 0 30px rgba(0,0,0,0.5)); }
.det-desc { font-size: 13px; color: #888; line-height: 1.6; max-height: 200px; overflow-y: auto; padding-right: 10px; }

/* COL 2: COMPONENTI */
.col-header { padding: 20px; font-size: 14px; font-weight: 800; color: #fff; background: #1a1a1e; border-bottom: 1px solid #333; letter-spacing: 1px; display: flex; justify-content: space-between; align-items: center; }
.col-scrollable { flex: 1; overflow-y: auto; padding: 20px; }

.component-block { margin-bottom: 25px; background: #18181b; border: 1px solid #27272a; border-radius: 8px; padding: 15px; }
.comp-name { font-size: 14px; font-weight: bold; color: #fff; margin-bottom: 10px; text-transform: uppercase; border-left: 3px solid var(--blue-energy); padding-left: 10px; display: flex; justify-content: space-between; }
.comp-owned { font-size: 10px; color: #666; }
.comp-owned.yes { color: #2ecc71; }

.relic-chips-container { display: flex; flex-wrap: wrap; gap: 8px; }
.relic-chip {
  background: #222; border: 1px solid #444; padding: 6px 12px;
  border-radius: 4px; cursor: pointer; display: flex; align-items: center; gap: 8px;
  transition: all 0.2s; position: relative;
}
.relic-chip:hover { border-color: #fff; background: #333; }
.relic-chip.selected { background: var(--gold); border-color: var(--gold); color: #000; box-shadow: 0 0 10px rgba(212,175,55,0.4); }
.relic-chip.vaulted { opacity: 0.6; border-style: dashed; }

.rc-name { font-size: 12px; font-weight: 800; }
.rc-rarity { width: 6px; height: 6px; border-radius: 50%; }
.rarity-Common { background: #cd7f32; }
.rarity-Uncommon { background: #c0c0c0; }
.rarity-Rare { background: #d4af37; }

/* COL 3: STRATEGIA */
.strategy-list { display: flex; flex-direction: column; gap: 10px; }
.strategy-placeholder { padding: 40px; text-align: center; color: #555; font-style: italic; font-size: 13px; }

.mission-row {
  display: flex; justify-content: space-between; align-items: center;
  background: #1a1a1e; border: 1px solid #333; padding: 10px 15px; border-radius: 4px;
}
.ms-loc { font-weight: bold; color: #fff; font-size: 13px; }
.ms-relic { color: var(--gold); font-size: 11px; font-weight: bold; margin-left: 10px; }
.ms-chance { color: var(--blue-energy); font-weight: bold; font-size: 12px; }

.vault-warning {
  background: rgba(231, 76, 60, 0.1); border: 1px solid #e74c3c; color: #e74c3c;
  padding: 15px; text-align: center; font-weight: bold; border-radius: 4px; margin-bottom: 10px;
}

/* src/app/modal.css */

/* SFONDO E CONTENITORE PRINCIPALE */
.modal-overlay {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  background: rgba(0, 0, 0, 0.9); backdrop-filter: blur(5px);
  z-index: 1000; display: flex; align-items: center; justify-content: center;
}

.modal-content.three-columns {
  width: 95vw; height: 90vh; max-width: 1600px;
  background: #121214; border: 1px solid #333; border-top: 3px solid var(--gold);
  display: flex; flex-direction: row; /* FONDAMENTALE: ORIZZONTALE */
  overflow: hidden; position: relative; box-shadow: 0 0 50px #000;
}

.close-btn {
  position: absolute; top: 10px; right: 20px; font-size: 30px;
  color: #fff; background: none; border: none; cursor: pointer; z-index: 100;
}
.close-btn:hover { color: var(--gold); }

/* DEFINIZIONE COLONNE */
.column-info { 
  flex: 0 0 25%; /* Larghezza fissa 25% */
  background: #0a0a0c; border-right: 1px solid #333; 
  display: flex; flex-direction: column; padding: 30px;
}

.column-components { 
  flex: 0 0 40%; /* Larghezza fissa 40% */
  background: #121214; border-right: 1px solid #333; 
  display: flex; flex-direction: column; 
}

.column-strategy { 
  flex: 1; /* Il resto dello spazio */
  background: #0e0e10; 
  display: flex; flex-direction: column; 
}

/* STILI INTERNI */
.det-title { font-size: 32px; font-weight: 900; color: #fff; margin: 0; text-transform: uppercase; }
.det-subtitle { color: var(--gold); font-size: 14px; font-weight: bold; margin-bottom: 20px; }
.det-img-box { flex: 1; display: flex; align-items: center; justify-content: center; margin-bottom: 20px; }
.det-img-box img { width: 100%; max-height: 400px; object-fit: contain; filter: drop-shadow(0 0 20px rgba(0,0,0,0.5)); }
.det-desc { font-size: 13px; color: #888; line-height: 1.5; overflow-y: auto; max-height: 200px; }

/* HEADER E SCROLL AREA PER COLONNE 2 e 3 */
.col-header { 
  padding: 15px; background: #1a1a1e; border-bottom: 1px solid #333; 
  font-size: 14px; font-weight: 800; color: #fff; letter-spacing: 1px; text-transform: uppercase;
}
.col-scrollable { flex: 1; overflow-y: auto; padding: 20px; }

/* COMPONENTI */
.component-block { margin-bottom: 20px; background: #18181b; border: 1px solid #27272a; border-radius: 6px; padding: 15px; }
.comp-name { font-size: 14px; font-weight: bold; color: #fff; margin-bottom: 10px; display: flex; justify-content: space-between; border-left: 3px solid var(--blue-energy); padding-left: 10px; }
.comp-owned { font-size: 10px; color: #666; font-weight: normal; }
.comp-owned.yes { color: #2ecc71; font-weight: bold; }

/* CHIPS RELIQUIE */
.relic-chips-container { display: flex; flex-wrap: wrap; gap: 8px; }
.relic-chip {
  background: #222; border: 1px solid #444; padding: 5px 10px; border-radius: 4px;
  cursor: pointer; display: flex; align-items: center; gap: 6px; transition: 0.2s;
}
.relic-chip:hover { border-color: #fff; background: #333; }
.relic-chip.selected { background: var(--gold); border-color: var(--gold); color: #000; }
.relic-chip.vaulted { opacity: 0.5; border-style: dashed; }

.rc-name { font-size: 11px; font-weight: 700; }
/* Pallini rarità */
.rc-rarity { width: 6px; height: 6px; border-radius: 50%; }
.rarity-Common { background: #cd7f32; box-shadow: 0 0 5px #cd7f32; }
.rarity-Uncommon { background: #c0c0c0; box-shadow: 0 0 5px #c0c0c0; }
.rarity-Rare { background: #d4af37; box-shadow: 0 0 5px #d4af37; }

/* MISSIONI */
.mission-row { 
  display: flex; justify-content: space-between; align-items: center; 
  padding: 8px 12px; background: #1a1a1e; border: 1px solid #333; 
  border-radius: 4px; margin-bottom: 8px; 
}
.ms-loc { font-weight: bold; color: #fff; font-size: 12px; }
.ms-relic { font-size: 10px; color: var(--gold); font-weight: bold; margin-bottom: 2px; }
.ms-chance { font-size: 11px; color: var(--blue-energy); font-weight: bold; }
.vault-warning { color: #e74c3c; border: 1px solid #e74c3c; padding: 10px; text-align: center; border-radius: 4px; font-weight: bold; font-size: 12px; margin-bottom: 15px; background: rgba(231,76,60,0.1); }
.strategy-placeholder { text-align: center; padding: 40px; color: #555; font-style: italic; font-size: 13px; }

==================================================
FILE: src\app\necramechs\page.js
==================================================

import CodexListPage from '@/components/CodexListPage';
import { fetchGameData } from '@/utils/serverData';

export default async function Page() {
    const data = await fetchGameData('Warframes.json'); // I mech sono qui dentro
    return <CodexListPage initialData={data} pageTitle="NECRAMECHS" categoryMode="necramechs" />;
}

==================================================
FILE: src\app\not-found.js
==================================================

// src/app/not-found.js
import Link from 'next/link';

export default function NotFound() {
  return (
    <div style={{
      height: '100vh', 
      display: 'flex', 
      flexDirection: 'column', 
      alignItems: 'center', 
      justifyContent: 'center', 
      color: 'white', 
      textAlign: 'center'
    }}>
      <h1 style={{fontSize: '40px', color: '#d4af37'}}>404 - ORDIS NOT FOUND</h1>
      <p>Operator, this coordinates do not exist.</p>
      <Link href="/" style={{marginTop:'20px', color:'#3b82f6', textDecoration:'underline'}}>
        Return to Orbiter (Home)
      </Link>
    </div>
  );
}

==================================================
FILE: src\app\page.js
==================================================

"use client";
import Link from 'next/link';
import { useState, useEffect } from 'react';
import { API_BASE_URL, IMG_BASE_URL } from '@/utils/constants';

// Aggiunto "Relics" alla lista
const CATEGORIES = [
    { id: 'warframes', title: 'Warframes', subtitle: 'The Arsenal', color: '#d4af37', link: '/warframes', jsonFile: 'Warframes.json' },
    { id: 'primary', title: 'Primary', subtitle: 'Rifles & Bows', color: '#ff6b6b', link: '/primary', jsonFile: 'Primary.json' },
    { id: 'secondary', title: 'Secondary', subtitle: 'Pistols', color: '#ff9f43', link: '/secondary', jsonFile: 'Secondary.json' },
    { id: 'melee', title: 'Melee', subtitle: 'Blades & Whips', color: '#feca57', link: '/melee', jsonFile: 'Melee.json' },
    { id: 'mods', title: 'Mods', subtitle: 'Upgrades', color: '#54a0ff', link: '/mods', jsonFile: 'Mods.json' },
    { id: 'relics', title: 'Relics', subtitle: 'Void Fissures', color: '#00d2d3', link: '/relics', jsonFile: 'Relics.json' }, // <--- NUOVA
    { id: 'companions', title: 'Companions', subtitle: 'Sentinels', color: '#1dd1a1', link: '/companions', jsonFile: 'Sentinels.json' },
    { id: 'amps', title: 'Amps', subtitle: 'Void Weapons', color: '#a29bfe', link: '/amps', jsonFile: 'Amps.json' }
];

function ApiImageCard({ cat }) {
    const [imgUrl, setImgUrl] = useState(null);

    useEffect(() => {
        let isMounted = true;
        async function fetchImage() {
            try {
                const res = await fetch(`${API_BASE_URL}/${cat.jsonFile}`);
                if (!res.ok) return;
                const data = await res.json();
                
                // Logica speciale per le Reliquie: prende la prima "Intact" o la prima disponibile
                let targetItem;
                if (cat.id === 'relics') {
                    targetItem = data.find(item => item.imageName && item.name.includes('Intact'));
                } else {
                    targetItem = data.find(item => item.name.includes("Prime") && item.imageName);
                }
                
                const firstValid = targetItem || data.find(item => item.imageName && !item.imageName.includes("fanart"));
                
                if (firstValid && isMounted) setImgUrl(`${IMG_BASE_URL}/${firstValid.imageName}`);
            } catch (e) { console.error(e); }
        }
        fetchImage();
        return () => { isMounted = false; };
    }, [cat.jsonFile, cat.id]);

    return (
        <Link href={cat.link} style={{textDecoration:'none'}}>
            <div 
                className="menu-card"
                style={{ '--card-color': cat.color, '--card-glow': `${cat.color}66` }}
            >
                <div className="card-visual-area">
                    {imgUrl ? <img src={imgUrl} alt={cat.title} className="card-img-element" /> : <div style={{background:'#111', width:'100%', height:'100%'}}></div>}
                </div>
                <div className="card-content">
                    <h2 className="card-title" style={{color: cat.color}}>{cat.title}</h2>
                    <p className="card-sub">{cat.subtitle}</p>
                </div>
            </div>
        </Link>
    );
}

export default function LandingPage() {
    return (
        <main className="landing-page">
            <div className="landing-content">
                <div className="landing-header">
                    <h1 className="landing-title">ORDIS CODEX</h1>
                    <div className="landing-subtitle">Tracker & Database System</div>
                </div>

                <div className="cards-scroll-container">
                    <div className="cards-row">
                        {CATEGORIES.map((cat) => (
                            <ApiImageCard key={cat.id} cat={cat} />
                        ))}
                    </div>
                </div>
                
                <div style={{marginTop:'40px', color:'#444', fontSize:'10px', textTransform:'uppercase', letterSpacing:'2px'}}>
                    Operator Interface v2.0
                </div>
            </div>
        </main>
    );
}

==================================================
FILE: src\app\primary\page.js
==================================================

import CodexListPage from '@/components/CodexListPage';
import { fetchGameData } from '@/utils/serverData';

export default async function Page() {
    const data = await fetchGameData('Primary.json');
    return <CodexListPage initialData={data} pageTitle="PRIMARY WEAPONS" />;
}

==================================================
FILE: src\app\relics\page.js
==================================================

"use client";
import { Suspense } from 'react';
import CodexListPage from '@/components/CodexListPage';

// --- Definizione Categorie (Resta invariata) ---
const createEraCategory = (id, label, eraName) => ({
    id: id,
    label: label,
    filter: (item) => item.name.includes(eraName),
    subFilters: [
        { id: 'all', label: 'INTACT (DEFAULT)', filter: (i) => i.name.includes('Intact') },
        { id: 'exceptional', label: 'EXCEPTIONAL', filter: (i) => i.name.includes('Exceptional') },
        { id: 'flawless', label: 'FLAWLESS', filter: (i) => i.name.includes('Flawless') },
        { id: 'radiant', label: 'RADIANT', filter: (i) => i.name.includes('Radiant') },
        { id: 'everything', label: 'SHOW ALL', filter: () => true }
    ]
});

const RELIC_CATEGORIES = [
    createEraCategory('lith', 'LITH', 'Lith'),
    createEraCategory('meso', 'MESO', 'Meso'),
    createEraCategory('neo', 'NEO', 'Neo'),
    createEraCategory('axi', 'AXI', 'Axi'),
    createEraCategory('requiem', 'REQUIEM', 'Requiem'),
];

export default function Page() {
    return (
        <Suspense fallback={<div style={{color:'#fff', padding:'50px', textAlign:'center'}}>Loading Void Fissures...</div>}>
            <CodexListPage 
                // Dice al componente di caricare "Relics.json" dalla cartella base configurata
                filesToLoad={['Relics.json']} 
                pageTitle="VOID RELICS" 
                customCategories={RELIC_CATEGORIES}
            />
        </Suspense>
    );
}

==================================================
FILE: src\app\secondary\page.js
==================================================

import CodexListPage from '@/components/CodexListPage';
import { fetchGameData } from '@/utils/serverData';

export default async function Page() {
    const data = await fetchGameData('Secondary.json');
    return <CodexListPage initialData={data} pageTitle="SECONDARY WEAPONS" />;
}

==================================================
FILE: src\app\warframes\page.js
==================================================

"use client";
import { Suspense } from 'react';
import CodexListPage from '@/components/CodexListPage';

const WARFRAME_CATEGORIES = [
    {
        id: 'all',
        label: 'WARFRAMES',
        filter: (item) => (item.type || "").toLowerCase() === 'warframe' && item.category === 'Warframes'
    }
];

export default function Page() {
    return (
        <Suspense fallback={<div style={{color:'#fff', padding:'50px', textAlign:'center'}}>Loading Interface...</div>}>
            <CodexListPage 
                filesToLoad={['Warframes.json']} 
                pageTitle="WARFRAMES" 
                customCategories={WARFRAME_CATEGORIES}
            />
        </Suspense>
    );
}

==================================================
FILE: src\components\CodexCard.js
==================================================

"use client";
import { useState, memo } from 'react';
import { IMG_BASE_URL, BASE_PATH } from '@/utils/constants';

// Helper dal vecchio file per calcolare le statistiche al volo
const getStatAtRank = (rank, maxRank, descriptionTemplate, levelStats) => {
    // Caso 1: Array di stats predefinito (Source: 59)
    if (levelStats && levelStats.length > 0) {
        let statsArray = levelStats[rank] ? levelStats[rank].stats : levelStats[levelStats.length - 1].stats;
        return statsArray.join('<br>');
    }
    // Caso 2: Calcolo matematico (Source: 61)
    if (!descriptionTemplate) return "";
    return descriptionTemplate.replace(/(\d+(\.\d+)?)/g, (match) => {
        const maxVal = parseFloat(match);
        const baseVal = maxVal / (maxRank + 1);
        const currentVal = baseVal * (rank + 1);
        return currentVal % 1 === 0 ? currentVal.toFixed(0) : currentVal.toFixed(1).replace(/\.0$/, '');
    }).replace(/\r\n|\n/g, "<br>");
};

const CodexCard = memo(function CodexCard({ item, isOwned, onToggleOwned }) {
    // Stato locale per il rank (solo per Mods/Arcanes)
    const [rank, setRank] = useState(item.maxRank || 0);

    const isMod = item.category === 'Mods';
    const isArcane = item.category === 'Arcanes';
    const isPrime = item.name.includes("Prime");
    
    // Logica aggiornamento rank (Source: 62)
    const updateRank = (e, change) => {
        e.stopPropagation();
        let newRank = rank + change;
        if (newRank < 0) newRank = 0;
        if (newRank > item.maxRank) newRank = item.maxRank;
        setRank(newRank);
    };

    // Determina cosa mostrare: Stats calcolate (se mod) o Descrizione statica
    let displayDesc = item.description || "Nessuna descrizione.";
    if (isMod || isArcane) {
        displayDesc = getStatAtRank(rank, item.maxRank, item.rawDescription || item.description, item.levelStats);
    }
    
    // Pulizia
    displayDesc = displayDesc.replace(/<br>/g, " <br/> "); 

    return (
        <div className={`card-wrapper ${isOwned ? 'owned' : ''}`} data-rarity={item.rarity || (isPrime ? 'Prime' : 'Common')}>
            
            {/* Immagine */}
            <div className="card-image-container">
                {/* Drain Box dal vecchio file (Source: 66) integrato nel nuovo stile */}
                {(item.baseDrain || item.polarityIcon) && (isMod || isArcane) && (
                    <div className="drain-box">
                        {item.baseDrain ? (item.baseDrain + rank) : ""}
                        {item.polarityIcon && <img src={item.polarityIcon} className="polarity-icon" alt="pol" />}
                    </div>
                )}

                {/* Checkbox */}
                <div className="owned-check" onClick={(e) => { e.stopPropagation(); onToggleOwned(item.uniqueName); }}>
                    {isOwned ? '✔' : ''}
                </div>

                {item.imageName ? (
                    <img 
                        src={`${IMG_BASE_URL}/${item.imageName}`} 
                        className="card-image-img" 
                        loading="lazy" 
                        alt={item.name}
                        style={isArcane ? { transform: 'scale(0.7)' } : {}} 
                    />
                ) : <div style={{fontSize:'10px', color:'#666'}}>{item.name}</div>}
            </div>

            {/* Info Area */}
            <div className="info-area">
                <div className="type-pill">{item.type}</div>
                <div className="mod-name" style={{color: isPrime ? 'var(--gold)' : '#fff'}}>
                    {item.name}
                </div>
                
                <div className="card-desc" dangerouslySetInnerHTML={{__html: displayDesc}}></div>

                {/* Rank Controls (Se è Mod/Arcane) - Source: 76 */}
                {(isMod || isArcane) && item.maxRank > 0 && (
                    <div className="rank-controls-container">
                        <button className="rank-btn" onClick={(e) => updateRank(e, -1)}>-</button>
                        <div className="ranks-dots">
                             {/* Mostriamo massimo 10 pallini per evitare overflow grafico */}
                            {Array.from({length: Math.min(item.maxRank + 1, 10)}).map((_, i) => (
                                <div key={i} className={`dot ${i <= (rank / item.maxRank * Math.min(item.maxRank, 9)) ? 'active' : ''}`}></div>
                            ))}
                        </div>
                        <button className="rank-btn" onClick={(e) => updateRank(e, 1)}>+</button>
                    </div>
                )}

                <a href={`https://warframe.fandom.com/wiki/${item.name.replace(/ /g, '_')}`} target="_blank" className="wiki-btn-block" onClick={(e) => e.stopPropagation()}>
                    WIKI
                </a>
            </div>
        </div>
    );
});

export default CodexCard;

==================================================
FILE: src\components\CodexListPage.js
==================================================

"use client";
import { useState, useEffect, useMemo, Suspense } from 'react'; // Aggiungi Suspense
import { useRouter, usePathname, useSearchParams } from 'next/navigation';
import CodexCard from './CodexCard';
import WarframeDetailModal from './WarframeDetailModal'; 
import { useOwnedItems } from '@/hooks/useOwnedItems';
import { API_BASE_URL } from '@/utils/constants';

// Componente interno che gestisce la logica e i parametri
function CodexContent({ filesToLoad = [], pageTitle, customCategories = null, manualData = null }) {
    const [rawApiData, setRawApiData] = useState([]);
    const [loading, setLoading] = useState(true);
    const [errorMsg, setErrorMsg] = useState(null);
    
    const searchParams = useSearchParams(); // Questo richiede Suspense
    const router = useRouter();
    const pathname = usePathname();
    const { ownedCards, toggleOwned, importItems } = useOwnedItems();
    const [selectedItem, setSelectedItem] = useState(null);

    const defaultCat = customCategories ? customCategories[0].id : 'all';
    const subCategory = searchParams.get('sub') || defaultCat;
    const [activeSubFilter, setActiveSubFilter] = useState('all');
    const [searchTerm, setSearchTerm] = useState("");
    const [showMissingOnly, setShowMissingOnly] = useState(false);
    const [visibleCount, setVisibleCount] = useState(60);

    const activeConfig = customCategories ? customCategories.find(c => c.id === subCategory) : null;
    const filesHash = filesToLoad.join(',');

    useEffect(() => {
        async function load() {
            setLoading(true);
            setErrorMsg(null);
            
            // Se abbiamo dati manuali (es. Relics)
            if (manualData && manualData.length > 0) {
                 // ... logica manualData (copia dal tuo codice precedente se necessario, o usa il blocco fetch sotto per tutto)
                 // Per brevità, qui mi concentro sul fix del fetch
                 const processed = manualData
                    .filter(i => i && !i.uniqueName.includes("RANDOM") && i.imageName) 
                    .map(item => ({
                        ...item,
                        maxRank: item.fusionLimit || item.maxLevel || 30,
                        baseDrain: item.baseDrain || 0,
                        polarityIcon: item.polarity ? `https://warframe.fandom.com/wiki/File:Polarity_${item.polarity.charAt(0).toUpperCase() + item.polarity.slice(1)}.png` : null 
                    }));
                const uniqueItems = Array.from(new Map(processed.map(item => [item.name, item])).values());
                uniqueItems.sort((a, b) => a.name.localeCompare(b.name));
                setRawApiData(uniqueItems);
                setLoading(false);
                return;
            }

            try {
                if (filesToLoad.length === 0) { setLoading(false); return; }

                // Fetch gestito SOLO lato client
                const promises = filesToLoad.map(f => 
                    fetch(`${API_BASE_URL}/${f}`)
                        .then(res => {
                            if (!res.ok) throw new Error(`HTTP ${res.status}`);
                            return res.json();
                        })
                        .catch(err => {
                            console.warn(`Skipping ${f}`, err);
                            return [];
                        })
                );

                const results = await Promise.all(promises);
                const merged = results.flat();

                const processed = merged
                    .filter(i => i && !i.uniqueName.includes("RANDOM") && i.imageName) 
                    .map(item => ({
                        ...item,
                        maxRank: item.fusionLimit || item.maxLevel || 30,
                        baseDrain: item.baseDrain || 0,
                        polarityIcon: item.polarity ? `https://warframe.fandom.com/wiki/File:Polarity_${item.polarity.charAt(0).toUpperCase() + item.polarity.slice(1)}.png` : null 
                    }));

                const uniqueItems = Array.from(new Map(processed.map(item => [item.name, item])).values());
                uniqueItems.sort((a, b) => a.name.localeCompare(b.name));
                
                setRawApiData(uniqueItems);
            } catch (e) { 
                console.error("Load error:", e); 
                setErrorMsg(e.message);
            }
            finally { setLoading(false); }
        }
        load();
    }, [filesHash, manualData]);

    // ... Logica di filtraggio (processedData) uguale a prima ...
    const processedData = useMemo(() => {
        return rawApiData.filter(item => {
            if (searchTerm && !item.name.toLowerCase().includes(searchTerm)) return false;
            if (showMissingOnly && ownedCards.has(item.uniqueName)) return false;
            if (activeConfig && activeConfig.filter && !activeConfig.filter(item)) return false;
            if (activeConfig && activeConfig.subFilters) {
                const subLogic = activeConfig.subFilters.find(sf => sf.id === activeSubFilter);
                if (subLogic && subLogic.filter && !subLogic.filter(item)) return false;
            }
            return true;
        });
    }, [rawApiData, subCategory, activeSubFilter, searchTerm, showMissingOnly, ownedCards, activeConfig]);

    const handleCategoryChange = (id) => {
        const p = new URLSearchParams(searchParams.toString());
        p.set('sub', id);
        router.push(`${pathname}?${p.toString()}`);
        setActiveSubFilter('all'); 
    };
    
    const handleImportAleca = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (ev) => {
            try {
                const json = JSON.parse(ev.target.result);
                importItems(Array.isArray(json) ? json : [], rawApiData);
                alert("Import riuscito!");
            } catch(e) { alert("File non valido"); }
        };
        reader.readAsText(file);
    };

    if (loading) return <div style={{padding:'50px', color:'#fff', textAlign:'center'}}>INITIALIZING ORDIS DATABASE...</div>;
    if (errorMsg) return <div style={{padding:'50px', color:'red', textAlign:'center'}}>{errorMsg}</div>;

    const pct = rawApiData.length > 0 ? Math.round((ownedCards.size / rawApiData.length) * 100) : 0;

    return (
        <div className="codex-layout">
            <div className="header-group">
                <div className="nav-top-row">
                    <div className="nav-brand">
                        <a href="/" className="nav-home-btn">⌂ DASHBOARD</a>
                        <h1 className="page-title">{pageTitle}</h1>
                    </div>
                    <div className="stats-right">
                        <div className="stat-box">
                            <div className="stat-label">COLLECTED</div>
                            <div className="stat-value"><span>{ownedCards.size}</span> / {rawApiData.length}</div>
                        </div>
                        <div className="stat-box">
                            <div className="stat-label">COMPLETION</div>
                            <div className="stat-value">{pct}%</div>
                        </div>
                    </div>
                </div>

                <div className="controls-row">
                    <div className="filters-left">
                        {customCategories && customCategories.length > 1 && (
                            <div className="category-tabs">
                                {customCategories.map(c => (
                                    <button key={c.id} className={`tab-btn ${subCategory === c.id ? 'active' : ''}`} onClick={() => handleCategoryChange(c.id)}>
                                        {c.label}
                                    </button>
                                ))}
                            </div>
                        )}
                         {activeConfig && activeConfig.subFilters && (
                            <div className="sub-filters-container">
                                {activeConfig.subFilters.map(sf => (
                                    <button key={sf.id} onClick={() => setActiveSubFilter(sf.id)} className={`pill-btn ${activeSubFilter === sf.id ? 'active' : ''}`}>
                                        {sf.label}
                                    </button>
                                ))}
                            </div>
                        )}
                    </div>
                    <div className="filters-right" style={{display:'flex', alignItems:'center', gap:'15px'}}>
                         <div className="search-wrapper">
                            <input type="text" className="search-input" placeholder="SEARCH..." value={searchTerm} onChange={(e) => setSearchTerm(e.target.value.toLowerCase())} />
                        </div>
                        <label className="toggle-missing">
                            <input type="checkbox" style={{display:'none'}} checked={showMissingOnly} onChange={(e) => setShowMissingOnly(e.target.checked)} />
                            <div className="checkbox-custom">{showMissingOnly && '✓'}</div>
                            MISSING
                        </label>
                         <button className="btn-import" onClick={() => document.getElementById('imp').click()}><span>📂</span> IMPORT</button>
                         <input type="file" id="imp" className="hidden-file-input" onChange={handleImportAleca} />
                    </div>
                </div>
                <div className="progress-line-container"><div className="progress-line-fill" style={{width: `${pct}%`}}></div></div>
            </div>

             <div className="gallery-scroll-area" onScroll={(e) => {
                if (e.target.scrollTop + e.target.clientHeight >= e.target.scrollHeight - 500) setVisibleCount(p => p + 60);
            }}>
                <div className="card-gallery">
                    {processedData.slice(0, visibleCount).map(item => (
                        <div key={item.uniqueName} onClick={() => setSelectedItem(item)} style={{cursor:'pointer'}}>
                            <CodexCard item={item} isOwned={ownedCards.has(item.uniqueName)} onToggleOwned={toggleOwned} />
                        </div>
                    ))}
                </div>
            </div>
            {selectedItem && (
                <WarframeDetailModal item={selectedItem} onClose={() => setSelectedItem(null)} ownedItems={ownedCards} onToggle={toggleOwned} />
            )}
        </div>
    );
}

// COMPONENTE PRINCIPALE CHE ESPORTIAMO
// Avvolge tutto in Suspense per risolvere l'errore di build
export default function CodexListPage(props) {
    return (
        <Suspense fallback={<div style={{color:'#fff', padding:'50px', textAlign:'center'}}>Loading Interface...</div>}>
            <CodexContent {...props} />
        </Suspense>
    );
}

==================================================
FILE: src\components\WarframeDetailModal.js
==================================================

"use client";
import React, { useEffect, useState } from 'react';
import { IMG_BASE_URL, API_BASE_URL } from '@/utils/constants';

const HIDDEN_RESOURCES = [
    'Orokin Cell', 'Argon Crystal', 'Neural Sensors', 'Neurodes', 
    'Plastids', 'Rubedo', 'Ferrite', 'Alloy Plate', 'Polymer Bundle', 
    'Circuits', 'Salvage', 'Morphics', 'Control Module', 'Gallium', 
    'Nitain Extract', 'Tellurium', 'Cryotic', 'Oxium'
];

export default function WarframeDetailModal({ item, onClose, ownedItems, onToggle }) {
    const [smartMissions, setSmartMissions] = useState([]);
    const [lookupData, setLookupData] = useState(null); 
    const [savedPartMap, setSavedPartMap] = useState({});
    
    const [selectedRelics, setSelectedRelics] = useState(new Set());
    const [loadingStrategies, setLoadingStrategies] = useState(false);
    const [statusMsg, setStatusMsg] = useState(""); 

    if (!item) return null;

    const isOwned = ownedItems.has(item.uniqueName);
    const isRelicItem = (item.category || "").includes('Relic') || (item.type || "").includes('Relic');
    const mainDropsEmpty = !item.drops || item.drops.length === 0;
    const isVaulted = item.vaulted || (isRelicItem && mainDropsEmpty);
    const wikiUrl = `https://warframe.fandom.com/wiki/${item.name.replace(/ /g, '_')}`;

    useEffect(() => {
        const handleEsc = (e) => { if (e.key === 'Escape') onClose(); };
        window.addEventListener('keydown', handleEsc);
        setSelectedRelics(new Set()); 
        
        if (!isRelicItem && (item.components || item.drops)) {
            fetchFarmingData();
        }
        return () => window.removeEventListener('keydown', handleEsc);
    }, [onClose, item]);

    // --- UTILS ---
    function getStandardID(name) {
        if (!name) return null;
        const match = name.toUpperCase().match(/(LITH|MESO|NEO|AXI|REQUIEM)\s+([A-Z0-9]+)/);
        if (match) return `${match[1]} ${match[2]}`;
        return null;
    }

    function getCleanPartName(fullComponentName) {
        if (!fullComponentName || fullComponentName === "MAIN BP") return "MAIN BP";
        const safeItemName = item.name.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); 
        const nameRegex = new RegExp(safeItemName, "gi");
        let clean = fullComponentName.replace(nameRegex, "").replace(/Blueprint/gi, "").replace(/Relic/gi, "").trim();
        if (fullComponentName.match(/Chassis/i)) return "CHASSIS";
        if (fullComponentName.match(/Systems/i)) return "SYSTEMS";
        if (fullComponentName.match(/Neuroptics/i)) return "NEURO";
        if (fullComponentName.match(/Harness/i)) return "HARNESS";
        if (fullComponentName.match(/Wings/i)) return "WINGS";
        if (!clean || clean.length < 2) return "MAIN BP";
        return clean.toUpperCase();
    }

    // --- HANDLER SELEZIONE ---
    const handleRelicClick = (relicId) => {
        if (!relicId) return;
        const newSet = new Set(selectedRelics);
        if (newSet.has(relicId)) {
            newSet.delete(relicId);
        } else {
            newSet.add(relicId);
        }
        setSelectedRelics(newSet);
    };

    const displayedMissions = (selectedRelics.size > 0 && lookupData) 
        ? calculateMissionsStrategy(selectedRelics, lookupData, savedPartMap)
        : smartMissions;

    function calculateMissionsStrategy(relicIdsSet, dbData, partMap) {
        const missionMap = new Map();

        relicIdsSet.forEach(relicID => {
            const missions = dbData[relicID]; 
            const partName = partMap[relicID] || "PART";

            if (missions) {
                missions.forEach(mission => {
                    const key = mission.node;
                    if (!missionMap.has(key)) {
                        missionMap.set(key, { missionName: key, totalScore: 0, relicsFound: [] });
                    }
                    const entry = missionMap.get(key);
                    let relicEntry = entry.relicsFound.find(r => r.id === relicID);
                    if (!relicEntry) {
                        relicEntry = { id: relicID, part: partName, drops: [], maxChance: 0 };
                        entry.relicsFound.push(relicEntry);
                    }
                    const dropExists = relicEntry.drops.some(d => d.rot === mission.rot);
                    if (!dropExists) {
                        relicEntry.drops.push({ rot: mission.rot, chance: mission.chance });
                        if (mission.chance > relicEntry.maxChance) relicEntry.maxChance = mission.chance;
                        entry.totalScore += mission.chance;
                    }
                });
            }
        });

        return Array.from(missionMap.values())
            .sort((a, b) => {
                const uniquePartsA = new Set(a.relicsFound.map(r => r.part)).size;
                const uniquePartsB = new Set(b.relicsFound.map(r => r.part)).size;
                if (uniquePartsB !== uniquePartsA) return uniquePartsB - uniquePartsA;
                return b.totalScore - a.totalScore;
            })
            .slice(0, 15);
    }

    async function fetchFarmingData() {
        setLoadingStrategies(true);
        setStatusMsg("Analyzing...");
        try {
            const neededIDs = new Set();
            const relicToPartMap = {}; 
            const scan = (drops, partNameLabel) => {
                (drops || []).forEach(d => {
                    const id = getStandardID(d.location);
                    if (id) { neededIDs.add(id); relicToPartMap[id] = getCleanPartName(partNameLabel); }
                });
            };
            (item.components || []).forEach(c => { if(!HIDDEN_RESOURCES.includes(c.name)) scan(c.drops, c.name); });
            scan(item.drops, "MAIN BP");

            setSavedPartMap(relicToPartMap);

            if (neededIDs.size === 0) { setLoadingStrategies(false); return; }

            const res = await fetch(`${API_BASE_URL}/RelicLookup.json`);
            if (!res.ok) throw new Error("Missing DB");
            const lookupDB = await res.json();
            setLookupData(lookupDB); 

            const initialStrategies = calculateMissionsStrategy(neededIDs, lookupDB, relicToPartMap);
            setSmartMissions(initialStrategies);

        } catch (e) { console.error(e); setStatusMsg("N/A"); } finally { setLoadingStrategies(false); }
    }

    // --- LOGICA FORMATTAZIONE COMPONENTI E VAULT STATUS ---
    function formatDropsWithVaultCheck(drops) {
        if(!drops || drops.length === 0) return [];
        const unique = new Map();
        
        drops.forEach(d => {
            let locRaw = d.location || "";
            let isRelic = locRaw.toUpperCase().match(/(LITH|MESO|NEO|AXI|REQUIEM)\s+[A-Z0-9]+/);
            if (isRelic && locRaw.match(/(Radiant|Flawless|Exceptional)/i)) return;
            
            let loc = locRaw.replace(' Relic', '').replace(' (Intact)', '').trim();
            let imagePath = null;
            let relicID = null;
            let isVaultedRelic = false;

            if (isRelic) {
                const slug = loc.toLowerCase().replace(/ /g, '-') + '-relic.png';
                imagePath = `${IMG_BASE_URL}/${slug}`;
                relicID = getStandardID(loc);
                
                // CHECK VAULT: Se il DB è caricato e l'ID non c'è, è Vaulted
                if (lookupData && relicID && !lookupData[relicID]) {
                    isVaultedRelic = true;
                }
            }

            if(!unique.has(loc)) {
                unique.set(loc, {
                    loc, isRelic, imagePath, relicID, isVaultedRelic,
                    pct: isRelic ? getIntactChance(d.rarity) : (d.chance ? `${(d.chance*100).toFixed(0)}%` : "-"),
                    chance: d.chance || 0
                });
            }
        });

        // ORDINAMENTO: Prima le disponibili, poi le vaulted, poi per chance
        return Array.from(unique.values()).sort((a, b) => {
            if (a.isVaultedRelic !== b.isVaultedRelic) return a.isVaultedRelic ? 1 : -1; // False (Available) first
            return b.chance - a.chance;
        });
    }

    const sortedRewards = item.rewards ? [...item.rewards].sort((a, b) => (b.chance || 0) - (a.chance || 0)) : [];
    const filteredComponents = (item.components || []).filter(comp => !HIDDEN_RESOURCES.includes(comp.name));
    const hasComponents = filteredComponents.length > 0;

    return (
        <div className="modal-overlay" onClick={onClose}>
            <div className="modal-content-simple" onClick={(e) => e.stopPropagation()}>
                <button className="close-btn" onClick={onClose}>&times;</button>

                <div className="modal-header-row">
                    <div style={{display:'flex', alignItems:'center', gap:'15px'}}>
                        <h2 className="modal-title">{item.name}</h2>
                        <div className="type-pill">{item.type}</div>
                    </div>
                    {isVaulted ? <div className="vault-badge is-vaulted">VAULTED</div> : <div className="vault-badge is-available">AVAILABLE</div>}
                </div>

                <div className="modal-body">
                    <div className="col-left">
                        <div style={{width:'100%', display:'flex', justifyContent:'center', marginBottom:'20px'}}>
                            <img src={`${IMG_BASE_URL}/${item.imageName}`} alt={item.name} style={{maxWidth:'100%', maxHeight:'250px'}} onError={(e)=>e.target.style.display='none'} />
                        </div>
                        {item.description && <p className="warframe-description">{item.description}</p>}
                        <button onClick={() => onToggle(item.uniqueName)} className={`btn-toggle-large ${isOwned ? 'owned' : ''}`}>
                            {isOwned ? '✔ POSSEDUTO' : '+ AGGIUNGI'}
                        </button>
                        <a href={wikiUrl} target="_blank" rel="noopener noreferrer" className="wiki-btn-block">WIKI PAGE</a>
                    </div>

                    <div className="col-center">
                        <h3 className="section-title">{isRelicItem ? "REWARDS" : "COMPONENTS"}</h3>
                        {isRelicItem && (
                            <div style={{display:'flex', flexDirection:'column', gap:'5px'}}>
                                {sortedRewards.map((r, i) => (
                                    <div key={i} style={{display:'flex', justifyContent:'space-between', padding:'8px', borderBottom:'1px solid #222', fontSize:'13px'}}>
                                        <span style={{color: '#aaa'}}>{r.itemName || r.item?.name}</span>
                                        <span style={{fontWeight:'bold', color:'var(--gold)'}}>{(r.chance*100).toFixed(0)}%</span>
                                    </div>
                                ))}
                            </div>
                        )}
                        {!isRelicItem && hasComponents && (
                            <div style={{display:'flex', flexDirection:'column', gap:'15px'}}>
                                {filteredComponents.map((comp, idx) => (
                                    <div key={idx} className="component-row">
                                        <div className="component-header">
                                            <div className="component-icon"><img src={`${IMG_BASE_URL}/${comp.imageName}`} alt=""/></div>
                                            <div style={{flex:1}}>
                                                <strong style={{color:'#eee', fontSize:'13px'}}>{getCleanPartName(comp.name)}</strong>
                                            </div>
                                            <span className="count-badge">x{comp.itemCount}</span>
                                        </div>
                                        <div className="relic-cards-grid">
                                            {formatDropsWithVaultCheck(comp.drops).map((d, i) => {
                                                const isSelected = d.relicID && selectedRelics.has(d.relicID);
                                                
                                                return (
                                                    <div 
                                                        key={i} 
                                                        onClick={() => d.isRelic && handleRelicClick(d.relicID)}
                                                        className={`mini-relic-card ${!d.isRelic ? 'is-mission' : ''} ${isSelected ? 'selected' : ''} ${d.isVaultedRelic ? 'is-vaulted' : ''}`}
                                                    >
                                                        {/* ICONA ESAGONO / FIAMMA */}
                                                        <svg className="relic-icon-svg" viewBox="0 0 24 24">
                                                            {d.isRelic ? (
                                                                <path d="M14.5 2C13.5 2 12.5 2.5 12 3.5C11.5 2.5 10.5 2 9.5 2C6 2 4 5 4 8C4 11 6 13 8 16C9 17.5 10 19.5 10 22H14C14 19.5 15 17.5 16 16C18 13 20 11 20 8C20 5 18 2 14.5 2ZM12 17C10.5 15 9 13.5 9 11C9 9.5 10 8.5 12 8.5C14 8.5 15 9.5 15 11C15 13.5 13.5 15 12 17Z" />
                                                            ) : (
                                                                <path d="M12 2L2 12l10 10 10-10L12 2zm0 18l-8-8 8-8 8 8-8 8z"/>
                                                            )}
                                                        </svg>
                                                        <div className="card-info">
                                                            <span className="card-name">{d.loc}</span>
                                                            <span className="card-pct">
                                                                {d.pct}
                                                                {d.isVaultedRelic && <span className="vaulted-mini-tag">V</span>}
                                                            </span>
                                                        </div>
                                                    </div>
                                                );
                                            })}
                                        </div>
                                    </div>
                                ))}
                            </div>
                        )}
                    </div>

                    <div className="col-right">
                        <div style={{display:'flex', justifyContent:'space-between', alignItems:'baseline', marginBottom:'10px'}}>
                            <h3 className="section-title" style={{color:'var(--gold)', margin:0}}>
                                {loadingStrategies ? statusMsg : (selectedRelics.size > 0 ? `FILTERED FARMING (${selectedRelics.size})` : "OPTIMAL FARMING LOCATIONS")}
                            </h3>
                            {selectedRelics.size > 0 && <span style={{fontSize:'10px', color:'#666', cursor:'pointer'}} onClick={()=>setSelectedRelics(new Set())}>(CLEAR FILTERS)</span>}
                        </div>

                        {!isRelicItem && displayedMissions.length > 0 ? (
                            <div className="strategy-container">
                                {displayedMissions.map((mission, idx) => (
                                    <div key={idx} className="mission-block">
                                        <div className="mission-block-header">
                                            <div className="mission-name-large">{mission.missionName}</div>
                                            {!selectedRelics.size && <div style={{fontSize:'10px', color:'#666', fontWeight:'bold'}}>{(mission.totalScore*100).toFixed(0)}% TOT</div>}
                                        </div>
                                        <table className="mission-relics-table">
                                            <thead>
                                                <tr>
                                                    <th style={{width:'30%'}}>RELIC</th>
                                                    <th style={{width:'20%', textAlign:'center'}}>PART</th>
                                                    <th style={{width:'20%', textAlign:'center'}}>ROT</th>
                                                    <th style={{width:'30%', textAlign:'right'}}>CHANCE</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                {mission.relicsFound.sort((a,b)=>b.maxChance - a.maxChance).map((r, i) => (
                                                    <tr key={i}>
                                                        <td style={{color:'#fff', fontWeight:'bold'}}>{r.id}</td>
                                                        <td style={{textAlign:'center'}}><span className="part-badge">{r.part}</span></td>
                                                        <td style={{textAlign:'center', color:'var(--gold)'}}>{(r.drops||[]).map(d=>d.rot).join(' | ')}</td>
                                                        <td style={{textAlign:'right', color:'#aaa'}}>{(r.drops||[]).map(d=>(d.chance*100).toFixed(1)+'%').join(' | ')}</td>
                                                    </tr>
                                                ))}
                                            </tbody>
                                        </table>
                                    </div>
                                ))}
                            </div>
                        ) : (
                            <div style={{textAlign:'center', padding:'40px', color:'#555', fontStyle:'italic'}}>
                                {!loadingStrategies && (selectedRelics.size > 0 ? "Selected relics are Vaulted or have no drop data." : "No farming data available.")}
                            </div>
                        )}
                    </div>
                </div>
            </div>
        </div>
    );
}

function getIntactChance(r) {
    if(!r) return "-";
    r = r.toLowerCase();
    if(r.includes('rare')) return "2%";
    if(r.includes('uncommon')) return "11%";
    return "25%";
}

==================================================
FILE: src\hooks\useItemStrategy.js
==================================================

// src/hooks/useItemStrategy.js
import { useState, useEffect, useMemo } from 'react';

// Utility pulizia nomi
const cleanRelicName = (fullName) => {
    return fullName.replace(" Relic", "").replace(/\s*\(.*?\)/g, "").trim();
};

export function useItemStrategy(item) {
    const [relicMap, setRelicMap] = useState(new Map());
    const [selectedRelics, setSelectedRelics] = useState(new Set());
    const [loadingRelics, setLoadingRelics] = useState(false);

    const isRelicItem = item?.category === 'Relics';

    // 1. Parsing Componenti
    const componentsList = useMemo(() => {
        if (isRelicItem || !item || !item.components) return [];
        
        const validParts = ['Blueprint', 'Chassis', 'Neuroptics', 'Systems', 'Harness', 'Wings', 'Engine', 'Cortex', 'Carapace', 'Cerebrum'];
        const filteredComponents = item.components.filter(comp => validParts.some(part => comp.name.includes(part)));
        
        // Ordinamento logico
        const order = ['Blueprint', 'Neuroptics', 'Chassis', 'Systems'];
        const sorted = [...filteredComponents].sort((a, b) => {
            const ia = order.findIndex(k => a.name.includes(k));
            const ib = order.findIndex(k => b.name.includes(k));
            return (ia === -1 ? 99 : ia) - (ib === -1 ? 99 : ib);
        });

        // Estrazione nomi reliquie necessarie
        return sorted.map(comp => {
            const rawRelics = (comp.drops || []).filter(d => d.location.includes(" Relic"));
            const uniqueRelics = new Map();
            
            rawRelics.forEach(d => {
                const baseName = cleanRelicName(d.location);
                if (!uniqueRelics.has(baseName)) {
                    uniqueRelics.set(baseName, { 
                        name: baseName, 
                        rarity: d.rarity || 'Common', 
                        chance: d.chance 
                    });
                }
            });

            return {
                name: comp.name.replace(item.name, "").replace("Blueprint", "BP").trim(),
                uniqueName: comp.uniqueName,
                relics: Array.from(uniqueRelics.values()).sort((a,b) => a.name.localeCompare(b.name))
            };
        });
    }, [item, isRelicItem]);

    // 2. Fetch Ottimizzato Reliquie (Solo quelle necessarie)
    useEffect(() => {
        if (!item) return;

        let relicsToFetch = [];
        if (isRelicItem) {
            relicsToFetch.push(cleanRelicName(item.name));
            setSelectedRelics(new Set([cleanRelicName(item.name)])); // Auto-select se è reliquia
        } else {
            // Raccogli tutti i nomi delle reliquie dai componenti
            componentsList.forEach(c => c.relics.forEach(r => relicsToFetch.push(r.name)));
        }

        // Rimuovi duplicati
        relicsToFetch = [...new Set(relicsToFetch)];

        if (relicsToFetch.length > 0) {
            setLoadingRelics(true);
            fetch('/api/relics/lookup', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ names: relicsToFetch })
            })
            .then(res => res.json())
            .then(data => {
                const map = new Map(data.map(r => [r.name, r]));
                setRelicMap(map);
            })
            .finally(() => setLoadingRelics(false));
        }
    }, [item, componentsList, isRelicItem]);

    // 3. Calcolo Strategia Farming
    const farmingStrategy = useMemo(() => {
        if (selectedRelics.size === 0) return null;
        const missions = [];
        const noDataRelics = [];

        selectedRelics.forEach(relicName => {
            const info = relicMap.get(relicName);
            // Se info manca ma siamo nella vista reliquia, usiamo i drop dell'item stesso
            const drops = info?.drops?.length > 0 ? info.drops : (isRelicItem ? item.drops : []);

            if (!drops || drops.length === 0) {
                noDataRelics.push(relicName);
            } else {
                drops.forEach(d => {
                    missions.push({
                        location: d.location,
                        relic: relicName,
                        chance: d.chance,
                        rotation: d.rotation
                    });
                });
            }
        });

        return {
            missions: missions.sort((a, b) => b.chance - a.chance).slice(0, 50),
            noData: noDataRelics
        };
    }, [selectedRelics, relicMap, item, isRelicItem]);

    const toggleRelic = (name) => {
        setSelectedRelics(prev => {
            const next = new Set(prev);
            if (next.has(name)) next.delete(name);
            else next.add(name);
            return next;
        });
    };

    return { 
        componentsList, 
        farmingStrategy, 
        selectedRelics, 
        toggleRelic,
        loadingRelics,
        isRelicItem
    };
}

==================================================
FILE: src\hooks\useOwnedItems.js
==================================================

// src/hooks/useOwnedItems.js
"use client";
import { useState, useEffect, useCallback } from 'react';

const STORAGE_KEY = 'warframe_codex_v7';

export function useOwnedItems() {
    const [ownedCards, setOwnedCards] = useState(new Set());
    const [isLoaded, setIsLoaded] = useState(false);

    // Carica dati all'avvio
    useEffect(() => {
        const saved = localStorage.getItem(STORAGE_KEY);
        if (saved) {
            try {
                setOwnedCards(new Set(JSON.parse(saved)));
            } catch (e) {
                console.error("Errore lettura salvataggio", e);
            }
        }
        setIsLoaded(true);
    }, []);

    // Salva dati ad ogni modifica
    useEffect(() => {
        if (isLoaded) {
            localStorage.setItem(STORAGE_KEY, JSON.stringify([...ownedCards]));
        }
    }, [ownedCards, isLoaded]);

    // Funzione ottimizzata per toggle
    const toggleOwned = useCallback((id) => {
        setOwnedCards(prev => {
            const newSet = new Set(prev);
            if (newSet.has(id)) newSet.delete(id);
            else newSet.add(id);
            return newSet;
        });
    }, []);

    // Funzione per import massivo (es. da file JSON)
    const importItems = useCallback((itemsArray, rawData) => {
        setOwnedCards(prev => {
            const newSet = new Set(prev);
            let count = 0;
            itemsArray.forEach(entry => {
                const name = (typeof entry === 'string' ? entry : entry.item_name || entry.name).toLowerCase();
                const found = rawData.find(i => i.name.toLowerCase() === name);
                if (found) {
                    newSet.add(found.uniqueName);
                    count++;
                }
            });
            return newSet;
        });
    }, []);

    return { ownedCards, toggleOwned, importItems, isLoaded };
}

==================================================
FILE: src\utils\categoryConfig.js
==================================================

// src/utils/categoryConfig.js

const isArcane = (item) => item.category === 'Arcanes' || (item.type && item.type.toLowerCase().includes('arcane'));
const isGalvanized = (item) => item.name.includes('Galvanized ') || item.name.includes('Primed ') || item.name.includes('Amalgam ');
const isArchon = (item) => item.name.includes('Archon ');
const isWeaponType = (item) => {
    const t = (item.type || "").toLowerCase();
    return t.includes('primary') || t.includes('secondary') || t.includes('melee') || t.includes('gun');
};

export const CATEGORY_CONFIGS = {
    'warframes': [
        { id: 'all', label: 'WARFRAMES', filter: (item) => (item.type || "").toLowerCase() === 'warframe' }
    ],
    'companions': [
        {
            id: 'robotic', label: 'SENTINELS', 
            filter: (item) => {
                const t = (item.type || "").toLowerCase();
                return t.includes('sentinel') || t.includes('robotic') || t.includes('moa');
            }
        },
        {
            id: 'beast', label: 'BEASTS',
            filter: (item) => {
                const t = (item.type || "").toLowerCase();
                return t.includes('kubrow') || t.includes('kavat') || t.includes('beast');
            }
        },
        {
            id: 'necramech', label: 'NECRAMECHS',
            filter: (item) => (item.type || "").toLowerCase().includes('necramech')
        }
    ],
    'mods': [
        {
            id: 'base', label: 'BASE MODS',
            filter: (item) => {
                const isSpecial = isGalvanized(item) || isArchon(item) || item.name.includes('Riven') || isArcane(item);
                const isMod = item.category === 'Mods' || (item.type || "").toLowerCase().includes('aura');
                return !isSpecial && isMod;
            },
            subFilters: [
                { id: 'all', label: 'ALL', filter: () => true }, // Changed TUTTI -> ALL
                { id: 'wf', label: 'WARFRAME', filter: (item) => (item.type || "").toLowerCase().includes('warframe') },
                { id: 'wep', label: 'WEAPONS', filter: (item) => isWeaponType(item) }
            ]
        },
        {
            id: 'elite', label: 'PRIMED & GALVANIZED',
            filter: (item) => isGalvanized(item)
        },
        {
            id: 'arcanes', label: 'ARCANES',
            filter: (item) => isArcane(item)
        }
    ]
};

==================================================
FILE: src\utils\constants.js
==================================================

// src/utils/constants.js

// URL Base: Punta alla cartella statica generata dallo script
export const API_BASE_URL = "/database_api";

export const IMG_BASE_URL = "https://cdn.warframestat.us/img";

export const REPO_NAME = 'warframecodex-next';
export const BASE_PATH = process.env.NODE_ENV === 'production' ? `/${REPO_NAME}` : '';

==================================================
FILE: src\utils\relicUtils.js
==================================================

// src/utils/relicUtils.js
import { fetchGameData } from '@/utils/serverData';

// Mappa globale per la sessione client
let relicCache = null;

export async function getRelicDatabase() {
    if (relicCache) return relicCache;

    try {
        // Scarica il file Relics.json (che ora è locale grazie a serverData)
        // Nota: In Next.js App Router, per i client component, usiamo una API route interna
        // Ma per semplificare, possiamo fare una chiamata fetch al file statico o usare l'API che creeremo
        const res = await fetch('/database_api/Relics.json'); // Legge dalla cartella public o via API
        
        // Se non funziona (es. siamo lato server), usiamo un fallback o l'API
        let data;
        if (!res.ok) {
             // Fallback: prova a chiamare l'API di sync se il file non è accessibile direttamente
             const apiRes = await fetch('/api/sync-db'); 
             // Questo è un workaround, l'ideale è che il client riceva i dati puliti
             data = await apiRes.json(); // Questo tornerebbe tutto, è pesante.
             // Meglio: Il client component riceve i dati delle reliquie via props o fetch ottimizzata.
             // Per ora assumiamo che il file sia accessibile o usiamo un metodo diretto.
             return new Map(); 
        } else {
             data = await res.json();
        }

        const map = new Map();
        
        data.forEach(item => {
            // FILTRO RIGIDO: Solo Reliquie, NO Radiant/Flawless/Exceptional
            if (item.category === 'Relics' && 
                !item.name.includes('(Radiant)') && 
                !item.name.includes('(Flawless)') && 
                !item.name.includes('(Exceptional)')) {
                
                // Pulizia Nome: "Lith G1 Relic (Intact)" -> "Lith G1"
                const cleanName = item.name
                    .replace(" Relic", "")
                    .replace(" (Intact)", "")
                    .trim();
                
                map.set(cleanName, {
                    id: item.uniqueName,
                    name: cleanName,
                    image: item.imageName,
                    drops: item.drops || [], // Dove si trova questa reliquia
                    vaulted: !item.drops || item.drops.length === 0
                });
            }
        });

        relicCache = map;
        return map;
    } catch (e) {
        console.error("Relic DB Error", e);
        return new Map();
    }
}

==================================================
FILE: src\utils\serverData.js
==================================================

// src/utils/serverData.js
import fs from 'fs/promises';
import path from 'path';
import { API_BASE_URL } from './constants';

const DB_FOLDER = path.join(process.cwd(), 'database_api');

// CACHE GLOBALE IN MEMORIA (Singleton pattern)
global.dataCache = global.dataCache || {};

export async function fetchGameData(filename, forceRefresh = false) {
    const filePath = path.join(DB_FOLDER, filename);

    // 1. CONTROLLO CACHE RAM (Velocità Massima)
    if (!forceRefresh && global.dataCache[filename]) {
        return global.dataCache[filename];
    }

    // 2. CONTROLLO LOCALE SU DISCO
    if (!forceRefresh) {
        try {
            const fileContent = await fs.readFile(filePath, 'utf-8');
            const json = JSON.parse(fileContent);
            if (Array.isArray(json) && json.length > 0) {
                // Salva in RAM per la prossima volta
                global.dataCache[filename] = json;
                return json;
            }
        } catch (error) {
            // File mancante o corrotto, procedi al download
        }
    }

    // 3. DOWNLOAD DA GITHUB
    try {
        console.log(`[SERVER] Downloading ${filename}...`);
        const url = `${API_BASE_URL}/${filename}`;
        const res = await fetch(url, { cache: 'no-store' }); // No fetch cache
        if (!res.ok) throw new Error(`HTTP Error ${res.status}: ${url}`);
        
        const data = await res.json();

        // 4. SALVATAGGIO DISCO + RAM
        try {
            await fs.mkdir(DB_FOLDER, { recursive: true });
            await fs.writeFile(filePath, JSON.stringify(data, null, 2));
            global.dataCache[filename] = data; // Aggiorna RAM
            console.log(`[SERVER] Saved: ${filePath}`);
        } catch (writeErr) {
            console.error(`[SERVER] Disk write error:`, writeErr);
        }

        return data;
    } catch (error) {
        console.error(`[SERVER ERROR] Failed to load ${filename}:`, error);
        return [];
    }
}

export async function fetchRelicsDB() {
    return await fetchGameData('Relics.json');
}